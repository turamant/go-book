<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 4</title>
</head>
<body>
    <h1>Глава 4. Ответы, управляемые базой данных</h1>
<p>Чтобы наше веб-приложение Snippetbox стало по-настоящему полезным, нам нужно где-то хранить (или
    сохранять) данные, введенные пользователями, а также возможность динамически запрашивать это хранилище данных во время
    выполнения.</p>
<p>Существует множество различных хранилищ данных, которые мы могли бы использовать для нашего приложения — каждое со своими
    плюсами и минусами — но мы выберем популярную реляционную базу данных MySQL.
</p>
<p>В этом разделе вы узнаете, как:</p>
   <ul>
    <li>Подключаться к MySQL из вашего веб-приложения (в частности, вы узнаете, как установить пул
        многократно используемых соединений).</li>
    <li>Создайте автономный пакет моделей, чтобы логика вашей базы данных могла повторно использоваться и
        была отделена от вашего веб-приложения.</li>
    <li>Используйте соответствующие функции в пакете Go database/sql для выполнения различных типов
        операторов SQL и узнайте, как избежать распространенных ошибок, которые могут привести к
        нехватке ресурсов вашего сервера.</li>
    <li>Предотвратите атаки путем внедрения SQL-кода, правильно используя параметры-заполнители.
    </li>
    <li>Используйте транзакции, чтобы вы могли выполнять несколько операторов SQL в одном атомарном действии.
    </li>
   </ul>     

<h2>Глава 4.1.Настройка MySQL</h2>

<p>Если вы следуете инструкциям, вам необходимо установить MySQL на свой компьютер на этом этапе. Официальная
    документация MySQL содержит исчерпывающие инструкции по установке для всех
    типов операционных систем, но если вы используете Mac OS, вы сможете установить ее с помощью:</p>

<pre><code class="terminal">$ brew install mysql</code></pre>
<p>Или, если вы используете дистрибутив Linux, который поддерживает apt (например, Debian и Ubuntu), вы можете
    установить его с помощью:</p>
<pre><code class="terminal">$ sudo apt install mysql-server</code></pre>
<p>Во время установки MySQL вас могут попросить установить пароль для пользователя root.
    Не забудьте запомнить это, если вы; он понадобится вам на следующем шаге.</p>
<h3>Формирование базы данных</h3>
<p>После установки MySQL вы сможете подключиться к ней со своего терминала как
    пользователь root. Команда для этого зависит от установленной версии MySQL
    . Для MySQL 5.7 вы сможете подключиться, набрав следующее:
</p>
<pre><code class="terminal">$ sudo mysql
    mysql></code></pre>
<p>Но если это не сработает, попробуйте вместо этого следующую команду, введя пароль
    , который вы установили во время установки.</p>
<pre><code class="terminal">$ mysql -u root -p
    Enter password:
    mysql></code></pre>
<p>После подключения первое, что нам нужно сделать, это создать базу данных в MySQL для хранения всех
    данных для нашего проекта. Скопируйте и вставьте следующие команды в приглашение mysql, чтобы
    создать новую базу данных snippetbox с использованием кодировки UTF8.</p>
<pre><code>-- Create a new UTF-8 `snippetbox` database.
    CREATE DATABASE snippetbox CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    -- Switch to using the `snippetbox` database.
    USE snippetbox;</code></pre>
<p>Затем скопируйте и вставьте следующую инструкцию SQL, чтобы создать новую таблицу фрагментов для хранения
    текстовых фрагментов для нашего приложения:</p>
<pre><code>-- Create a `snippets` table.
    CREATE TABLE snippets (
    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    created DATETIME NOT NULL,
    expires DATETIME NOT NULL
    );
    -- Add an index on the created column.
    CREATE INDEX idx_snippets_created ON snippets(created);
</code></pre>
<p>Каждая запись в этой таблице будет иметь целочисленное поле идентификатора, которое будет действовать как уникальный идентификатор
    для текстового фрагмента. Он также будет иметь короткий текстовый заголовок, а само содержимое фрагмента будет
    храниться в поле содержимого. Мы также сохраним некоторые метаданные о времени
    создания фрагмента и сроке его действия.</p>
<p>Давайте также добавим несколько записей-заполнителей в таблицу фрагментов (которые мы будем использовать в следующих
    нескольких главах). Я буду использовать короткие хайку в качестве содержания текстовых фрагментов, но
    на самом деле не имеет значения, что они содержат.  </p>

<pre><code>-- Add some dummy records (which we'll use in the next couple of chapters).
    INSERT INTO snippets (title, content, created, expires) VALUES (
    'An old silent pond',
    'An old silent pond...\nA frog jumps into the pond,\nsplash! Silence again.\n\n– Matsuo Bashō',
    UTC_TIMESTAMP(),
    DATE_ADD(UTC_TIMESTAMP(), INTERVAL 365 DAY)
    );
    INSERT INTO snippets (title, content, created, expires) VALUES (
    'Over the wintry forest',
    'Over the wintry\nforest, winds howl in rage\nwith no leaves to blow.\n\n– Natsume Soseki',
    UTC_TIMESTAMP(),
    DATE_ADD(UTC_TIMESTAMP(), INTERVAL 365 DAY)
    );
    INSERT INTO snippets (title, content, created, expires) VALUES (
    'First autumn morning',
    'First autumn morning\nthe mirror I stare into\nshows my father''s face.\n\n– Murakami Kijo',
    UTC_TIMESTAMP(),
    DATE_ADD(UTC_TIMESTAMP(), INTERVAL 7 DAY)
    );</code></pre>       
    

<h3>Создание нового пользователя</h3>
<p>С точки зрения безопасности не рекомендуется подключаться к MySQL в качестве пользователя root
    из веб-приложения. Вместо этого лучше создать пользователя базы данных с ограниченными
    правами доступа к базе данных.</p>
<p>Итак, пока вы все еще подключены к командной строке MySQL, выполните следующие команды, чтобы
    создать нового веб-пользователя с привилегиями SELECT и INSERT только в базе данных.</p>

<pre><code>CREATE USER 'web'@'localhost';
    GRANT SELECT, INSERT, UPDATE ON snippetbox.* TO 'web'@'localhost';
    -- Important: Make sure to swap 'pass' with a password of your own choosing.
    ALTER USER 'web'@'localhost' IDENTIFIED BY 'pass';</code></pre>
<p>Как только это будет сделано, введите exit, чтобы выйти из приглашения MySQL.</p>
<h3>Протестируйте нового пользователя.</h3>
<p>Теперь вы сможете подключиться к базе данных snippetbox в качестве веб-пользователя, используя следующую
    команду. При появлении запроса введите пароль, который вы только что установили.
</p>
<pre><code class="terminal">$ mysql -D snippetbox -u web -p
    Enter password:
    mysql></code></pre>
<p>Если разрешения работают правильно, вы обнаружите, что можете
    правильно выполнять операции SELECT и INSERT в базе данных, но другие команды, такие как DROP TABLE
    и GRANT, завершатся ошибкой.</p>
<pre><code>mysql> SELECT id, title, expires FROM snippets;
    +----+------------------------+---------------------+
    | id | title | expires |
    +----+------------------------+---------------------+
    | 1 | An old silent pond | 2019-09-07 11:46:10 |
    | 2 | Over the wintry forest | 2019-09-07 11:46:10 |
    | 3 | First autumn morning | 2022-09-14 11:46:11 |
    +----+------------------------+---------------------+
    mysql> DROP TABLE snippets;
    ERROR 1142 (42000): DROP command denied to user 'web'@'localhost' for table 'snippets'</code></pre>
<h2>Глава 4.2. Установка драйвера базы данных</h2>
<p>Чтобы использовать MySQL из нашего веб-приложения Go, нам нужно установить драйвер базы данных. По сути, он
    действует как посредник, переводя команды между Go и
    самой базой данных MySQL.</p>    
<p>Вы можете найти полный список доступных драйверов на вики Go, но для нашего приложения
    мы будем использовать популярный драйвер go-sql-driver/mysql.
    Чтобы загрузить его, перейдите в каталог вашего проекта и запустите команду go get, например
</p>  
    
<pre><code class="terminal">$ cd $HOME/code/snippetbox
    $ go get github.com/go-sql-driver/mysql@v1
    go: downloading github.com/go-sql-driver/mysql v1.5.0</code></pre>

<p>Обратите внимание, что мы добавляем к пути пакета постфикс @v1, чтобы указать, что мы хотим загрузить
    последнюю доступную версию пакета с номером основного выпуска 1.</p>
<p>На момент написания это версия 1.5.0, но версия, которую вы загружаете может быть v1.5.1, v1.6.0
    или аналогичный — и это нормально. Поскольку пакет go-sql-driver/mysql использует семантическое
    управление версиями для своих выпусков, любая версия v1.xx должна быть совместима с остальным кодом
    в этой книге.</p>
<p>Кроме того, если вы хотите загрузить последнюю версию, независимо от номера версии, вы
    можете просто опустить суффикс @version следующим образом:</p>

<pre><code class="terminal">$ go get github.com/go-sql-driver/mysql</code></pre>
<p>Или, если вы хотите загрузить определенную версию пакета, вы можете использовать полный
    номер версии. Например:</p>
<pre><code class="terminal">$ go get github.com/go-sql-driver/mysql@v1.0.3</code></pre>
<p>После установки драйвера взгляните на свой файл go.mod (который мы создали в самом
    начале книги). Вы должны увидеть новую строку require, содержащую путь к пакету и
    точную версию, которая была загружена:</p>
<pre><code>File: go.mod
    module turamantedwards.net/snippetbox
    go 1.15
    require github.com/go-sql-driver/mysql v1.5.0</code></pre>

<p>Вы также увидите, что в корне каталога вашего проекта был создан новый файл с именем
    go.sum.</p>
<p><img src="static/images/picture4.1.png"/></p>
<p>Этот файл go.sum содержит криптографические контрольные суммы, представляющие содержимое
    необходимых пакетов. Если вы откроете его, вы должны увидеть что-то вроде этого:</p>
<pre><code>File: go.sum
    github.com/go-sql-driver/mysql v1.5.0 h1:ozyZYNQW3x3HtqT1jira07DN2PArx2v7/mN66gGcHOs=
    github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=</code></pre>
<p>В отличие от файла go.mod файл go.sum не предназначен для редактирования человеком, и, как правило,
    его не нужно открывать. Но он выполняет две полезные функции:</p>
<ul>
    <li>Если вы запустите команду go mod verify со своего терминала, это проверит, что контрольные
        суммы загруженных пакетов на вашем компьютере совпадают с записями в go.sum,
        поэтому вы можете быть уверены, что они не были изменены.</li>
    <li>Если кому-то еще нужно загрузить все зависимости для проекта — что он
        может сделать, запустив go mod download — он получит сообщение об ошибке, если есть какое-либо несоответствие
        между загружаемыми зависимостями и контрольными суммами в файле.</li>
</ul>

<h3>Дополнительная информация</h3>
<h4>Обновление пакетов</h4>
<p>После того, как пакет загружен и добавлен в ваш файл go.mod, пакет и
    версия становятся «фиксированными». Но есть много причин, по которым вы можете захотеть обновиться, чтобы использовать более новую
    версию пакета в будущем.</p>
<p>Чтобы обновить до последней доступной дополнительной версии или исправления пакета, вы можете просто запустить
    go get с флагом -u следующим образом:</p>

<pre><code class="terminal">$ go get -u github.com/foo/bar</code></pre>
<p>Или, наоборот, если вы хотите перейти на определенную версию, вам следует запустить ту же
    команду, но с соответствующим суффиксом @version. Например:</p>
<pre><code class="terminal">$ go get -u github.com/foo/bar@v2.0.0</code></pre>
<h3>Удаление неиспользуемых пакетов</h3>
<p>Иногда вы можете получить пакет только для того, чтобы позже в вашей сборке понять, что
    он вам больше не нужен. Когда это происходит, у вас есть два варианта.</p>
<p>Вы можете либо запустить go get, либо указать путь к пакету с постфиксом @none, например:</p>
<pre><code class="terminal">$ go get github.com/foo/bar@none</code></pre>
<p>Или, если вы удалили все ссылки на пакет в своем коде, вы можете запустить
    go mod tidy, который автоматически удалит все неиспользуемые пакеты из ваших
    файлов go.mod и go.sum.</p>
<pre><code class="terminal">$ go mod tidy -v</code></pre>

<h2>Глава 4.3. Создание пула соединений с базой данных</h2>
<p>Теперь, когда база данных MySQL настроена и у нас установлен драйвер, следующим естественным
    шагом будет подключение к базе данных из нашего веб-приложения.</p>
<p>Для этого нам понадобится функция Go sql.Open(), которую вы используете примерно так:
</p>
<pre><code>// Функция sql.Open() инициализирует новый объект sql.DB, который, по сути, является
// пулом соединений с базой данных.
    db, err := sql.Open("mysql", "web:pass@/snippetbox?parseTime=true"),
    если err != nil {
    ...
    }</code></pre>
<p>В этом коде есть несколько вещей, которые нужно объяснить и подчеркнуть:</p>
<ul>
    <li>Первый параметр sql.Open() — это имя драйвера, а второй параметр — это
        имя источника данных (иногда также называемое строкой подключения или DSN), которое описывает,
        как подключиться . в вашу базу данных.</li>
    <li>Формат имени источника данных будет зависеть от используемой базы данных и драйвера
        . Как правило, вы можете найти информацию и примеры в документации для вашего
        конкретного драйвера. Для драйвера, который мы используем, вы можете найти эту документацию здесь.</li>
    <li>Приведенная выше часть parseTime=true DSN — это параметр, специфичный для драйвера, который указывает
        нашему драйверу преобразовывать поля SQL TIME и DATE в объекты Go time.Time.</li>
    <li>Функция sql.Open() возвращает объект sql.DB. Это не соединение с базой данных — это
        пул многих соединений. Это важное различие для понимания. Go управляет
        этими соединениями по мере необходимости, автоматически открывая и закрывая соединения с
        базой данных через драйвер.</li>
    <li>Пул соединений безопасен для одновременного доступа, поэтому вы можете
        безопасно использовать его из обработчиков веб-приложений.</li>
    <li>Пул соединений предназначен для длительного использования. В веб-приложении нормально инициализировать
        пул соединений в вашей функции main(), а затем передать пул вашим
        обработчикам. Вы не должны вызывать sql.Open() в самом короткоживущем обработчике — это будет пустой
        тратой памяти и сетевых ресурсов.</li>
</ul>
<h3>Использование в нашем веб-приложении</h3>
<p>Давайте посмотрим, как использовать sql.Open() на практике. Откройте файл main.go и добавьте
    следующий код:</p>
<pre><code>Файл: cmd/web/main.go
    package main
    
    import (
        "database/sql" // Новый импорт
        "flag"
        "log"
        "net/http"
        "os"
        _ "github.com/go-sql-driver/mysql" // Новый импорт
    )
    ...
    func main() {
        addr := flag.String("addr", ":4000", "HTTP network address")
        // Определить новый флаг командной строки для строки DSN MySQL.
        dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true",
         "имя источника данных MySQL") flag.Parse(
        )
        infoLog := log.New(os.Stdout, "INFO\ t", log.Ldate|log.Ltime)
        errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.
        
        // объединение в отдельную функцию openDB() ниже. Мы передаем openDB() DSN
        // из флага командной строки.
        db, err := openDB(*dsn)
        if err != nil {
            errorLog.Fatal(err)
        }
        // Мы также откладываем вызов db.Close(), так что пул соединений закрывается
        // перед main( ) функция завершает работу.
        defer db.Close()
        app := &application{
        errorLog: errorLog,
        infoLog: infoLog,
        }
        srv := &http.Server{
        Addr: *addr,
        ErrorLog: errorLog,
        Handler: app.routes(),
        }
        infoLog.Printf(" Запуск сервера на %s", *addr)
        // Поскольку переменная err уже объявлена ​​в приведенном выше коде, нам нужно
        // использовать здесь оператор присваивания = вместо оператора := 'объявить и присвоить'
        //.
        err = srv.ListenAndServe()
        errorLog.Fatal(err)
    }
    
    // Функция openDB() оборачивает sql.Open() и возвращает пул соединений sql.DB
    // для данного DSN.
    func openDB(dsn string) (*sql.DB, error) {
        db, err := sql.Open("mysql", dsn)
        if err != nil {
            return nil, err
        }
        if err = db.Ping(); err != nil {
            return nil, err
        }
        return db, nil
    }
</code></pre>

<p>В этом коде есть несколько интересных моментов:</p>
<ul>
    <li>Обратите внимание, путь импорта для нашего драйвера начинается со знака подчеркивания? Это потому, что
        наш файл main.go на самом деле ничего не использует в пакете mysql. Поэтому, если мы попытаемся
        импортировать его в обычном режиме, компилятор Go выдаст ошибку.
        Однако нам нужно запустить функцию init() драйвера , чтобы она могла зарегистрироваться в пакете database/sql. Хитрость
        , чтобы обойти это, состоит в том, чтобы связать имя пакета с пустым идентификатором. Это
        стандартная практика для большинства SQL-драйверов Go.</li>
    <li>Функция sql.Open() на самом деле не создает никаких соединений, все, что она делает, это инициализирует
        пул для будущего использования. Фактические соединения с базой данных устанавливаются лениво, т.к.
        когда нужно в первый раз. Итак, чтобы убедиться, что все настроено правильно, нам нужно использовать
        метод db.Ping() для создания соединения и проверки на наличие ошибок.</li>
    <li>На данный момент вызов defer db.Close() немного излишен. Наше
        приложение всегда завершается прерыванием сигнала (например, Ctrl+c) или
        errorLog.Fatal(). В обоих этих случаях программа завершается немедленно, а отложенные
        функции никогда не запускаются. Но включение db.Close() — это хорошая привычка, и это может
        быть полезно позже в будущем, если вы добавите корректное завершение работы в свое приложение.</li>
</ul>
<h3>Проверка подключения</h3>
<p>Убедитесь, что файл сохранен, а затем попробуйте запустить приложение. Если все идет
    по плану, пул соединений должен быть установлен, и метод db.Ping() должен
    создать соединение без каких-либо ошибок. Если все хорошо, вы должны увидеть обычное
    сообщение Starting server… в журнале:</p>
<pre><code class="terminal">$ go run ./cmd/web
    INFO 2022/09/07 13:54:19 Starting server on :4000</code></pre>
<p>Если приложение не запускается и вы получаете сообщение об ошибке «Отказано в доступе...», как показано ниже, проблема, вероятно, связана с вашим DSN. Дважды проверьте правильность имени пользователя и
    пароля, что у пользователей вашей базы данных есть правильные разрешения и что ваш
    экземпляр MySQL использует стандартные настройки.</p>

<pre><code class="terminal">$ go run ./cmd/web
    ERROR 2022/09/07 13:55:51 main.go:44: Error 1045: Access denied for user 'web'@'localhost' (using password: YES)
    exit status 1</code></pre>

   <h2>Глава 4.4. Проектирование модели базы данных</h2>
<p>В этой главе мы собираемся набросать модель базы данных для нашего проекта.</p>
<p>Если вам не нравится термин модель, вы можете
    вместо этого думать о ней как о сервисном уровне или уровне доступа к данным. Как бы вы это ни называли, идея в том, что код для работы с MySQL мы инкапсулируем
    в отдельный пакет к остальному нашему приложению.</p>
<p>Сейчас мы создадим скелет модели базы данных и заставим ее возвращать немного фиктивных данных. Это
    мало что даст, но я хотел бы объяснить шаблон, прежде чем мы углубимся в суть SQL-
    запросов.</p>
<p>Звук нормальный? Затем давайте продолжим и создадим пару новых папок и файлов в
    каталоге pkg:</p>
<pre><code class="terminal">$ cd $HOME/code/snippetbox
$ mkdir -p pkg/models/mysql
$ touch pkg/models/models.go
$ touch pkg/models/mysql/snippets.go</code></pre>

<p><img src="static/images/picture4.2.png"/></p>

<p class="note">Помните: каталог pkg используется для хранения вспомогательного
    кода, не относящегося к конкретному приложению, который потенциально можно использовать повторно. Модель базы данных, которая может использоваться
    другими приложениями в будущем (например, приложение с интерфейсом командной строки), отвечает всем требованиям.</p>
<p>Мы начнем с использования файла pkg/models/models.go для определения типов данных верхнего уровня, которые
    будет использовать и возвращать наша модель базы данных. Откройте его и добавьте следующий код:</p>
<pre><code>File: pkg/models/models.go
    package models
    import (
    "errors"
    "time"
    )
    var ErrNoRecord = errors.New("models: no matching record found")
    type Snippet struct {
    ID int
    Title string
    Content string
    Created time.Time
    Expires time.Time
}</code></pre>
<p>Заметили, как поля структуры Snippet соответствуют полям в нашей
    таблице фрагментов MySQL?</p>
<p>Теперь перейдем к файлу pkg/models/mysql/snippets.go, который будет содержать код
    специально для работы с сниппетами в нашей базе данных MySQL. В этом файле мы собираемся
    определить новый тип SnippetModel и реализовать некоторые методы для доступа к
    базе данных и управления ею. Вот так:</p>

<pre><code>File: pkg/models/mysql/snippets.go

    package mysql
    
    import (
        "database/sql"
        // Импортируем только что созданный пакет моделей. Вам нужно указать перед этим
        // любой путь к модулю, который вы установили в главе 02.02 (Настройка проекта и включение
        // модулей), чтобы оператор импорта выглядел следующим образом:
        // "{ваш-модуль-путь}/pkg/models ".
        "turamant.net/snippetbox/pkg/models"
    )
    // Определите тип SnippetModel, который является оболочкой для пула соединений sql.DB.
    type SnippetModel struct {
        DB *sql.DB
    }
    // Это вставит новый фрагмент в базу данных.
    func (m *SnippetModel) Insert(title, content, expires string) (int, error) {
        return 0, nil
    }
    // Это вернет определенный фрагмент на основе его идентификатора.
    func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
        return nil, nil
    }
    // Это вернет 10 последних созданных фрагментов.
    func (m *SnippetModel) Latest() ([]*models.Snippet, error) {
        return nil, nil
    }</code></pre>

<p>Еще одна важная вещь, на которую следует обратить внимание, — это оператор импорта для
    turamant.net/snippetbox/pkg/models. Заметили, что путь импорта для нашего внутреннего
    пакета начинается с пути к модулю, который я выбрал в самом начале книги?</p>
<h3>Использование SnippetModel</h3>
<p>Чтобы использовать эту модель в наших обработчиках, нам нужно установить новую структуру SnippetModel в main(),
    а затем внедрить ее как зависимость через структуру приложения — точно так же, как мы сделали с
    другими нашими зависимостями.</p>
<p>Вот как:</p>

<pre><code>File: cmd/web/main.go

    package main

    import (
        "database/sql"
        "flag"
        "log"
        "net/http"
        "os"
        "turamant.net/snippetbox/pkg/models/mysql" // Новый импорт
        _ "github.com/go-sql-driver/mysql"
    )
    ...
    // Добавляем поле фрагментов в структуру приложения. Это позволит нам
    // сделать объект SnippetModel доступным для наших обработчиков.
    type application struct {
        errorLog *log.Logger
        infoLog *log.Logger
        snippets *mysql.SnippetModel
    }

    func main() {
        dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "MySQL data source name")
        addr := flag.String("addr", ":4000", "HTTP network address")
        flag.Parse()
        infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
        errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
        db, err := openDB(*dsn)
        if err != nil {
            errorLog.Fatal(err)
        }
        defer db.Close()
        
        // Инициализировать экземпляр mysql.SnippetModel и добавить его в приложение
        // зависимости.
        app := &application{
            errorLog: errorLog,
            infoLog: infoLog,
            snippets: &mysql.SnippetModel{DB: db},
        }
        srv := &http.Server{
            Addr: *addr,
            ErrorLog: errorLog,
            Handler: app.routes(),
        }
        infoLog.Printf("Starting server on %s", *addr)
        err = srv.ListenAndServe()
        errorLog.Fatal(err)
    }
    ...</code></pre>
<h3>Дополнительная информация</h3>
<h4>Преимущества этой структуры</h4>
<p>Настройка ваших моделей таким образом может показаться немного сложной и запутанной, особенно если
    вы новичок в Go, но по мере того, как наше приложение продолжает расти, должно становиться яснее,
    почему мы структурируем вещи, как мы.</p>
<p>Если вы сделаете шаг назад, вы сможете увидеть несколько новых преимуществ:</p>
<ul>
    <li>Существует четкое разделение задач. Логика нашей базы данных не привязана к нашим обработчикам,
        что означает, что обязанности обработчиков ограничены HTTP-вещами (т.е. проверка
        запросов и написание ответов). Это облегчит написание плотных, сфокусированных модульных тестов
        в будущем.</li>
    <li>Создав собственный тип SnippetModel и внедрив в него методы, мы
        Мы можем сделать нашу модель единым, аккуратно инкапсулированным объектом, который мы можем легко
        инициализировать, а затем передать нашим обработчикам в качестве зависимости. Опять же, это упрощает поддержку
        и тестируемость кода.</li>
    <li>Поскольку действия модели определяются как методы объекта — в нашем случае
        SnippetModel — есть возможность создать интерфейс и смоделировать его для
        целей модульного тестирования.</li>
    <li>У нас есть полный контроль над тем, какая база данных используется во время выполнения, просто с помощью
        флага командной строки.</li>
    <li>И, наконец, структура каталогов хорошо масштабируется, если в вашем проекте несколько серверных частей.
        Например, если некоторые ваши данные хранятся в Redis, вы можете поместить все модели для них в
        пакет pkg/models/redis.</li>
</ul>

<h2>Глава 4.5. Выполнение операторов SQL</h2>
<p>Теперь давайте изменим метод SnippetModel.Insert(), который мы только что создали, чтобы он
    создавал новую запись в нашей таблице фрагментов, а затем возвращал целочисленный идентификатор для новой
    записи.</p>
<p>Для этого нам нужно выполнить следующий SQL-запрос к нашей базе данных:</p>

<pre><code>INSERT INTO snippets (title, content, created, expires)
    VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))</code></pre>

<p>Обратите внимание, как в этом запросе мы используем ? символ для указания параметров-заполнителей для
    данных, которые мы хотим вставить в базу данных? Поскольку данные, которые мы будем использовать,
    в конечном итоге будут ненадежным пользовательским вводом из формы, рекомендуется использовать
    параметры-заполнители вместо интерполяции данных в SQL-запросе.</p>

<h3>Выполнение Query</h3>
<p>Go предоставляет три различных метода для выполнения запросов к базе данных:
</p>
<ul>
    <li>DB.Query() используется для запросов SELECT, которые возвращают несколько строк.
    </li>
    <li>DB.QueryRow() используется для запросов SELECT, которые возвращают одну строку.
    </li>
    <li>DB.Exec() используется для операторов, которые не возвращают строки (например, INSERT и DELETE).
    </li>
</ul>
<p>Итак, в нашем случае наиболее подходящим инструментом для работы является DB.Exec(). Давайте углубимся
    и продемонстрируем, как использовать это в нашем методе SnippetModel.Insert().
    Детали обсудим потом.</p>
<p>Откройте файл pkg/models/mysql/snippets.go и обновите его следующим образом:
</p>
<pre><code>Файл: pkg/models/mysql/snippets.go

    package mysql
    ...
    type SnippetModel struct {
        DB *sql.DB
    }
    func (m *SnippetModel) Insert(title, content, expires string) (int, error) {
        
        // Напишите оператор SQL, который мы хотим выполнить. Я разделил его на две строки
        // для удобочитаемости (именно поэтому он заключен в обратные кавычки
        // вместо обычных двойных кавычек).
        stmt := `INSERT INTO snippets (title, content, created, expires)
                    VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))`
    
        // Используйте метод Exec() во встроенном пуле соединений для
        // выполнения инструкции. Первый параметр — это оператор SQL, за которым
        // следуют заголовок, содержимое и значения срока действия для параметров-заполнителей. Этот
        // метод возвращает объект sql.Result, содержащий некоторую
        // базовую информацию о том, что произошло при выполнении инструкции.            
        result, err := m.DB.Exec(stmt, title, content, expires)
        
        if err != nil {
            return 0, err
        }
        
        // Используйте метод LastInsertId() для объекта результата, чтобы получить идентификатор нашей
        // вновь вставленной записи в таблицу фрагментов.
        id, err := result.LastInsertId()
        if err != nil {
            return 0, err
        }
        // Возвращаемый идентификатор имеет тип int64, поэтому мы конвертируем его в тип int
        // перед возвратом.
        return int(id), nil
    }
    ...</code></pre>

<p>Давайте быстро обсудим интерфейс sql.Result, возвращаемый функцией DB.Exec(). Это предоставляет два
    метода:</p>
<ul>
    <li>LastInsertId() — который возвращает целое число (int64), сгенерированное базой данных в
        ответ на команду. Обычно это будет из столбца «автоинкремент» при
        вставке новой строки, что и происходит в нашем случае.</li>
    <li>RowsAffected() — возвращает количество строк (как int64), затронутых оператором.</li>
</ul>
<p class="note">Важно: не все драйверы и базы данных поддерживают методы LastInsertId() и
    RowsAffected(). Например, LastInsertId() не поддерживается
    PostgreSQL. Поэтому, если вы планируете использовать эти методы, важно
    сначала проверить документацию для вашего конкретного драйвера.</p>

<p>Кроме того, вполне приемлемо (и распространено) игнорировать возвращаемое значение sql.Result, если
    оно вам не нужно. Вот так:</p>

<pre><code>_, err := m.DB.Exec("INSERT INTO ...", ...)</code></pre>

<h3>Использование модели в наших обработчиках</h3>
<p>Давайте вернемся к чему-то более конкретному и продемонстрируем, как вызывать этот новый
    код из наших обработчиков. Откройте файл cmd/web/handlers.go и обновите
    обработчик createSnippet следующим образом:</p>

<pre><code>File: cmd/web/handlers.go
    package main
    ...
    func (app *application) createSnippet(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
        w.Header().Set("Allow", http.MethodPost)
        app.clientError(w, http.StatusMethodNotAllowed)
        return
        }
        
        // Создадим несколько переменных, содержащих фиктивные данные. Мы удалим их позже
        // во время сборки.
        title := "O snail"
        content := "O snail\nClimb Mount Fuji,\nBut slowly, slowly!\n\n– Kobayashi Issa"
        expires := "7"

        // Передаем данные в метод SnippetModel.Insert(), получая
        // обратно ID новой записи.
        id, err := app.snippets.Insert(title, content, expires)
        if err != nil {
        app.serverError(w, err)
        return
        }
        
        // Перенаправляем пользователя на соответствующую страницу фрагмента.
        http.Redirect(w, r, fmt.Sprintf("/snippet?id=%d", id), http.StatusSeeOther)
    }</code></pre>

<p>Запустите приложение, затем откройте второе окно терминала и используйте curl, чтобы сделать
    запрос POST /snippet/create, например (обратите внимание, что флаг -L указывает curl автоматически следовать
    перенаправлениям):</p>

<pre><code class="terminal">$ curl -iL -X POST http://localhost:4000/snippet/create
    HTTP/1.1 303 See Other
    Location: /snippet?id=4
    Date: Fri, 07 Sep 2018 15:04:57 GMT
    Content-Length: 0
    HTTP/1.1 200 OK
    Date: Fri, 07 Sep 2018 15:04:57 GMT
    Content-Length: 39
    Content-Type: text/plain; charset=utf-8
    Display a specific snippet with ID 4...</code></pre>

<p>Так что это работает довольно хорошо. Мы только что отправили HTTP-запрос, который активировал наш
    обработчик createSnippet, который, в свою очередь, вызвал наш метод SnippetModel.Insert(). Это
    вставило новую запись в базу данных и вернуло идентификатор этой новой записи. Затем наш обработчик
    выполнил перенаправление на другой URL-адрес с идентификатором в качестве параметра строки запроса.
    </p>
<p>Не стесняйтесь заглянуть в таблицу фрагментов вашей базы данных MySQL. Вы должны увидеть
    новую запись с идентификатором 4, похожую на эту:</p>

<pre><code class="terminal">mysql> SELECT id, title, expires FROM snippets;
    +----+------------------------+---------------------+
    | id | title | expires |
    +----+------------------------+---------------------+
    | 1 | An old silent pond | 2019-09-07 11:46:10 |
    | 2 | Over the wintry forest | 2019-09-07 11:46:10 |
    | 3 | First autumn morning | 2018-09-14 11:46:11 |
    | 4 | O snail | 2018-09-14 15:04:57 |
    +----+------------------------+---------------------+
    4 rows in set (0.00 sec)</code></pre>  
      
<h3>Дополнительная информация</h3>
<h4>Параметры-заполнители</h4>
<p>В приведенном выше коде мы построили наш оператор SQL с использованием параметров-заполнителей, где
    ? выступал в качестве заполнителя для данных, которые мы хотим вставить.
    </p>
<p>Причина использования параметров-заполнителей для построения нашего запроса (а не
    интерполяции строк) заключается в том, чтобы помочь избежать атак с внедрением SQL из любого ненадежного пользовательского
    ввода.</p>
<p>За кулисами метод DB.Exec() работает в три этапа:</p>

<ol>
    <li>Он создает новый подготовленный оператор в базе данных, используя предоставленный оператор SQL.
        База данных анализирует и компилирует оператор, а затем сохраняет его готовым к выполнению.
        </li>
    <li>На втором отдельном шаге Exec() передает значения параметров в базу данных. Затем база
        данных выполняет подготовленный оператор, используя эти параметры. Поскольку
        параметры передаются позже, после компиляции оператора, база данных
        обрабатывает их как чистые данные. Они не могут изменить намерение заявления. Пока
        исходный оператор не получен из ненадежных данных, внедрение не может произойти.
        </li>
    <li>Затем он закрывает (или освобождает) подготовленный оператор в базе данных.
    </li>
</ol>
<p>Синтаксис параметра-заполнителя зависит от вашей базы данных. MySQL, SQL Server
и SQLite используют ? нотация, но PostgreSQL использует нотацию $N. Например, если
бы вы использовали PostgreSQL вместо этого, вы бы написали:</p>
<pre><code>_, err := m.DB.Exec("INSERT INTO ... VALUES ($1, $2, $3)", ...)</code></pre>

<h2>Глава 4.6. SQL-запросы с одной записью</h2>
<p>Шаблон для выбора одной записи из базы данных немного сложнее.
    Давайте объясним, как это сделать, обновив наш метод SnippetModel.Get(), чтобы он возвращал один
    конкретный фрагмент на основе его идентификатора.</p>
<p>Для этого нам нужно выполнить следующий SQL-запрос к базе данных:</p>

<pre><code>SELECT id, title, content, created, expires FROM snippets
    WHERE expires > UTC_TIMESTAMP() AND id = ?</code></pre>

<p>Поскольку наша таблица фрагментов использует столбец id в качестве первичного ключа, этот запрос всегда будет
    возвращать только одну строку базы данных (или вообще ничего). Запрос также включает проверку
    времени истечения срока действия, чтобы мы не возвращали фрагменты с истекшим сроком действия.
    </p>
<p>Обратите внимание, что мы снова используем параметр-заполнитель для значения id?
</p>
<p>Откройте файл pkg/models/mysql/snippets.go и добавьте следующий код:</p>    

<pre><code>File: pkg/models/mysql/snippets.go

    package mysql

    import (
        "database/sql"
        "errors" // New import
        "turamant.net/snippetbox/pkg/models"
    )
    type SnippetModel struct {
        DB *sql.DB
    }
    ...

    func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
        // Напишите оператор SQL, который мы хотим выполнить. Опять же, я разделил его на две
        // строки для удобства чтения.
        stmt := `SELECT id, title, content, created, expires FROM snippets
                WHERE expires > UTC_TIMESTAMP() AND id = ?`
        
        // Используйте метод QueryRow() в пуле соединений, чтобы выполнить наш
        // оператор SQL, передав ненадежную переменную id в качестве значения
        // параметра-заполнителя. Это возвращает указатель на объект sql.Row, который
        // содержит результат из базы данных.
        row := m.DB.QueryRow(stmt, id)

        // Инициализировать указатель на новую обнуленную структуру Snippet.
        s := &models.Snippet{}

        // Используйте row.Scan() для копирования значений из каждого поля в sql.Row
        // в соответствующее поле в структуре Snippet. Обратите внимание, что аргументы
        // для row.Scan являются *указателями* на место, в которое вы хотите скопировать
        // данные, и количество аргументов должно точно совпадать с
        // количеством столбцов, возвращаемых вашим оператором.
        err := row.Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
        
        if err != nil {
            // Если запрос не возвращает строк, то row.Scan() вернет
            // ошибку sql.ErrNoRows. Мы используем функцию error.Is() для проверки этой
            // ошибки и вместо этого возвращаем 
            // нашу собственную ошибку models.ErrNoRecord.
            if errors.Is(err, sql.ErrNoRows) {
                return nil, models.ErrNoRecord
            } else {
                return nil, err
            }
        }
        // Если все прошло нормально, возвращаем объект Snippet.
        return s, nil
    }
    ...</code></pre>

<p class="note">В сторону: вам может быть интересно, почему мы возвращаем ошибку models.ErrNoRecord
    вместо sql.ErrNoRows напрямую. Причина в том, чтобы помочь полностью инкапсулировать модель
    , чтобы наше приложение не зависело от базового хранилища данных и не
    зависело от ошибок, связанных с хранилищем данных, в своем поведении.
</p>
<h3>Проверка</h3>
<h3>Преобразования типов</h3>
<p>За кулисами rows.Scan() ваш драйвер автоматически преобразует необработанный вывод
    из базы данных SQL в требуемые нативные типы Go. Пока вы хорошо разбираетесь в
    типах, которые вы сопоставляете между SQL и Go, эти преобразования обычно должны просто
    работать. Обычно:</p>
<ul>
    <li>CHAR, VARCHAR и TEXT отображаются в string.</li>
    <li>BOOLEAN отображается в bool.</li>
    <li>INT отображается в int; BIGINT сопоставляется с int64.</li>
    <li>DECIMAL и NUMERIC отображается в float.</li>
    <li>TIME, DATE и TIMESTAMP сопоставляются с time.Time.</li>
</ul>
<p>Причуда нашего драйвера MySQL заключается в том, что нам нужно использовать параметр parseTime=true в нашем
    DSN, чтобы заставить его преобразовывать поля TIME и DATE в time.Time. В противном случае он возвращает их как
    []байтовые объекты. Это один из многих параметров, специфичных для драйвера, которые он предлагает.
    </p>
<h3>Использование модели в наших обработчиках</h3>
<p>Итак, давайте задействуем метод SnippetModel.Get().</p>
<p>Откройте файл cmd/web/handlers.go и обновите обработчик showSnippet, чтобы он возвращал
    данные для конкретной записи в виде HTTP-ответа:</p>

<pre><code>File: cmd/web/handlers.go

    package main
    
    import (
        "errors" // Новый импорт
        "fmt"
        "html/template"
        "net/http"
        "strconv"
        "turamant.net/snippetbox/pkg/models" // Новый импорт
    )
    ...
    func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
        id, err := strconv.Atoi(r.URL.Query().Get("id"))
        if err != nil || id < 1 {
            app.notFound(w)
            return
        }

        // Используйте метод Get объекта SnippetModel для извлечения данных для
        // конкретной записи на основе ее идентификатора. Если соответствующая запись не найдена,
        // вернуть ответ 404 Not Found.
        s, err := app.snippets.Get(id)

        if err != nil {
            if errors.Is(err, models.ErrNoRecord) {
                app.notFound(w)
            } else {
                app.serverError(w, err)
            }
        return
        }

        // Запишите данные фрагмента в виде обычного текстового тела ответа HTTP.
        fmt.Fprintf(w, "%v", s)
    }
    ...</code></pre>   
    <p>Давайте попробуем. Перейдите в свой веб-браузер и посетите
        http://localhost:4000/snippet?id=1. Вы должны увидеть HTTP-ответ, похожий
        на этот</p>
<p><img src="static/images/picture4.3.png"/></p>
<p>Вы также можете попробовать сделать некоторые запросы для других фрагментов, срок действия которых истек или
    еще не существует (например, id=99 ), чтобы убедиться, что они возвращают ответ 404 Not Found:</p>
<p><img src="static/images/picture4.4.png"/></p>

<h3>Дополнительная информация</h3>
<h4>Дозорные:  Errors и errors.Is()</h4>
<p>В приведенном выше коде мы использовали функцию errors.Is(), представленную в Go 1.13
    , для проверки соответствия ошибки определенному значению (в нашем случае мы хотели проверьте,
    соответствует ли ошибка sql.ErrNoRows).</p>
<p>Есть пара вещей, о которых я хотел бы поговорить подробнее.</p>
<p>Во-первых, sql.ErrNoRows является примером того, что известно как сигнальная ошибка,
    которую мы можем приблизительно определить как объект ошибки, хранящийся в глобальной переменной. Обычно вы
    создаете их с помощью функции errors.New(). Пара примеров дозорных ошибок из
    стандартной библиотеки: io.ErrUnexpectedEOF и bytes.ErrTooLarge, а также наша собственная
    Ошибка models.ErrNoRecord, которую мы только что создали, также является примером ошибки дозорного.
    </p>
<p>В более старых версиях Go (до 1.13) идиоматический способ проверить, соответствует ли ошибка конкретной
    дозорной ошибке, был таким:</p>

<pre><code>if err == sql.ErrNoRows {
    // Do something
    } else {
    // Do something else
}</code></pre>

<p>Но начиная с версии Go 1.13 лучше использовать вместо нее функцию errors.Is(), например s</p>
<pre><code>if errors.Is(err, sql.ErrNoRows) {
    // Do something
    } else {
    // Do something else
}</code></pre>

<p>Причина этого в том, что в Go 1.13 появилась возможность оборачивать ошибки для добавления дополнительной
    информации. А если дозорная ошибка завернута, то старый стиль проверки совпадения
    перестанет работать, потому что завернутая ошибка не равна исходной дозорной ошибке.
    </p>
<p>Напротив, функция errors.Is() работает, распаковывая ошибки — при необходимости — перед
    проверкой совпадения.</p>
<p>В общем, если вы используете Go 1.13 или новее, предпочтите использовать errors.Is(). Это разумный
    способ защитить ваш код в будущем и предотвратить проблемы, вызванные вами — или любыми пакетами, которые
    импортирует ваш код — ошибки переноса в будущем.</p>

<p>Существует также другая функция, errors.As(), которую вы можете использовать, чтобы проверить,
    имеет ли (потенциально завернутая) ошибка определенный тип. Мы будем использовать это позже в этой книге.
</p>
<p>Для получения дополнительной информации об изменениях ошибок Go 1.13 вы можете прочитать официальный FAQ.
</p>
<h4>Сокращенные запросы с одной записью</h4>
<p>Я намеренно сделал код в SnippetModel.Get() немного многословным, чтобы помочь прояснить
    и подчеркнуть, что происходит за кулисами вашего кода.</p>
<p>На практике вы можете сократить код (или, по крайней мере, количество строк!), используя тот
    факт, что ошибки из DB.QueryRow() откладываются до вызова Scan(). Это не имеет никакого
    функционального значения, но если вы хотите, вполне нормально переписать код, чтобы он выглядел
    примерно так:
</p>     
<pre><code>func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
    s := &models.Snippet{}
    err := m.DB.QueryRow("SELECT ...", id).Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, models.ErrNoRecord
        } else {
            return nil, err
        }
    }

    return s, nil
}</code></pre> 

<h2>Глава 4.7. SQL-запросы с несколькими записями</h2>
<p>Наконец, давайте рассмотрим шаблон выполнения операторов SQL, которые возвращают несколько строк. Я
    продемонстрирую, обновив метод SnippetModel.Latest(), чтобы он возвращал десять последних
    созданных фрагментов (при условии, что срок их действия не истек), используя следующий SQL-запрос:
    </p>
<pre><code>SELECT id, title, content, created, expires FROM snippets
    WHERE expires > UTC_TIMESTAMP() ORDER BY created DESC LIMIT 10</code></pre>
<p>Откройте файл pkg/models/mysql/snippets.go и добавьте следующий код:</p>

<pre><code>File: pkg/models/mysql/snippets.go

    package mysql
    
    import (
        "database/sql"
        "errors"
        "turamant.net/snippetbox/pkg/models"
    )
    type SnippetModel struct {
        DB *sql.DB
    }
    ...

    func (m *SnippetModel) Latest() ([]*models.Snippet, error) {
        // Напишите оператор SQL, который мы хотим выполнить.
        stmt := `SELECT id, title, content, created, expires FROM snippets
        WHERE expires > UTC_TIMESTAMP() ORDER BY created DESC LIMIT 10`

        // Используйте метод Query() в пуле соединений, чтобы выполнить наш
        //оператор SQL. Это возвращает набор результатов sql.Rows, содержащий 
        // результат нашего запроса.
        rows, err := m.DB.Query(stmt)

        if err != nil {
            return nil, err
        }

        // Мы откладываем rows.Close(), чтобы убедиться, что результирующий набор sql.Rows
        // всегда корректно закрывается перед возвратом из метода Latest(). Этот
        // оператор defer должен появиться *после* того, как вы проверите наличие ошибки в 
        // методе Query(). В противном случае, если Query() вернет ошибку,
        // вы получите панику при попытке закрыть нулевой набор результатов.

        defer rows.Close()

        // Инициализировать пустой фрагмент для хранения объектов models.Snippets.
        snippets := []*models.Snippet{}

        // Используйте rows.Next для перебора строк в результирующем наборе. Это
        // подготавливает первую (а затем и каждую последующую) строку для обработки методом
        // rows.Scan(). Если итерация по всем строкам завершается,
        // метод rows.Scan(). Если итерация по всем строкам завершается,
        // результирующий набор автоматически закрывается и освобождает базовое
        // соединение с базой данных.
        for rows.Next() {
            // Создаем указатель на новую обнуленную структуру Snippet.
            s := &models.Snippet{}

            // Используйте rows.Scan(), чтобы скопировать значения из каждого поля в строке
            // в новый объект Snippet, который мы создали. Опять же, аргументы для row.Scan()
            // должны быть указателями на место, в которое вы хотите скопировать 
            // данные, а количество аргументов должно точно совпадать с
            // количеством столбцов, возвращаемых вашим оператором.
            err = rows.Scan(&s.ID, &s.Title, &s.Content, &s.Created, &s.Expires)
            
            if err != nil {
                return nil, err
            }
            
            // Добавляем его к фрагменту сниппетов.
            snippets = append(snippets, s)
            }
        
        // Когда цикл rows.Next() завершится, мы вызываем rows.Err() для получения
        // любой ошибки, возникшей во время итерации. Это важно
        // вызывать — не думайте, что успешная итерация была завершена
        // для всего набора результатов.
        if err = rows.Err(); err != nil {
            return nil, err
        }

        // Если все прошло нормально, возвращаем слайс Snippets.
        return snippets, nil
    }</code></pre>
<p class="note">Важно: закрытие результирующего набора с помощью defer rows.Close() здесь имеет решающее значение. Пока
    результирующий набор открыт, он будет держать базовое соединение с базой данных открытым… поэтому, если
    что-то пойдет не так в этом методе и результирующий набор не будет закрыт, это может быстро привести
    к тому, что все соединения в вашем пуле будут израсходованы.</p>

<h3>Использование модели в наших обработчиках</h3>
<p>Вернитесь к файлу cmd/web/handlers.go и обновите домашний обработчик, чтобы он использовал
    метод SnippetModel.Latest(), выводя содержимое фрагмента в ответ HTTP. А
    пока просто закомментируйте код, относящийся к рендерингу шаблона, например:</p>

<pre><code>File: cmd/web/handlers.go

    package main
    
    import (
        "errors"
        "fmt"
        // "html/template"
        "net/http"
        "strconv"
        "turamant.net/snippetbox/pkg/models"
    )

    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        for _, snippet := range s {
            fmt.Fprintf(w, "%v\n", snippet)
        }
        // files := []string{
        // "./ui/html/home.page.tmpl",
        // "./ui/html/base.layout.tmpl",
        // "./ui/html/footer.partial.tmpl",
        // }
        // ts, err := template.ParseFiles(files...)
        // if err != nil {
        // app.serverError(w, err)
        // return
        // }
        // err = ts.Execute(w, nil)
        // if err != nil {
        // app.serverError(w, err)
        // }
    }
    ...</code></pre>
<p>Если вы запустите приложение сейчас и посетите http://localhost:4000 в своем браузере, вы должны
    получить ответ, подобный этому:</p>
<p><img src="static/images/picture4.5.png"/></p>

<h2>Глава 4.8. Транзакции и другие подробности.</h2>
<h3>Пакет database/sql</h3>
<p>Как вы, вероятно, начинаете понимать, пакет database/sql по существу обеспечивает
    стандартный интерфейс между вашим приложением Go и миром баз данных SQL.</p>
<p>Пока вы используете пакет database/sql, написанный вами код Go, как правило, будет
    переносимым и будет работать с любой базой данных SQL — будь то MySQL, PostgreSQL,
    SQLite или что-то еще. Это означает, что ваше приложение не так тесно связано с
    базой данных, которую вы используете в настоящее время, и теоретически вы можете поменять местами базы данных в будущем,
    не переписывая весь свой код (особенности драйверов и реализации SQL
    в сторону).</p>
<p>Важно отметить, что хотя база данных/sql в целом обеспечивает стандартный
    интерфейс для работы с базами данных SQL, существуют некоторые особенности в том,
    как работают разные драйверы и базы данных. Всегда полезно прочитать
    документацию для нового драйвера, чтобы понять любые особенности и крайние случаи, прежде чем вы начнете
    его использовать.</p>

<h3>Многословность</h3>

<p>Если вы работаете с Ruby, Python или PHP, код для запросов к базам данных SQL может показаться немного
    многословным, особенно если вы привыкли иметь дело со слоем абстракции или ORM.
    </p>
<p>Но преимущество многословия в том, что наш код не волшебный; мы можем понять и
    точно контролировать то, что происходит. И со временем вы обнаружите, что шаблоны для
    создание SQL-запросов становится привычным, и вы можете копировать и вставлять из предыдущей работы.
    </p>
<p>Если многословность действительно начинает раздражать вас, вы можете попробовать
    пакет jmoiron/sqlx. Он хорошо разработан и предоставляет несколько хороших расширений, которые делают
    работу с SQL-запросами быстрее и проще.</p>
<h3>Управление значениями NULL</h3>
<p>В Go не очень хорошо получается управлять значениями NULL в записях базы данных. Давайте представим, что столбец title в нашей таблице фрагментов содержит значение NULL в определенной
    строке. Если бы мы запросили эту строку, то rows.Scan() вернул бы ошибку, потому что
    не может преобразовать NULL в строку:</p>
<pre><code class="terminal">sql: Scan error on column index 1: unsupported Scan, storing driver.Value type
    &lt;nil&gt; into type *string</code></pre>

<p>Грубо говоря, исправить это можно, изменив поле, в которое вы сканируете, из строки
    в тип sql.NullString. См. эту суть для рабочего примера.</p>
<p>Но, как правило, проще всего вообще избегать значений NULL. Установите ограничения NOT NULL
    для всех столбцов вашей базы данных, как мы это сделали в этой книге, вместе с
    разумными значениями DEFAULT, если это необходимо.
    </p>
<h3>Работа с транзакциями</h3>
<p>Важно понимать, что вызовы Exec(), Query() и QueryRow() могут использовать любое
    соединение из пула sql.DB. Даже если у вас есть два вызова Exec() непосредственно друг за
    другом в вашем коде, нет гарантии, что они будут использовать одно и то же
    соединение с базой данных.</p>
<p>Иногда это неприемлемо. Например, если вы блокируете таблицу с помощью
    команды MySQL LOCK TABLES, вы должны вызвать UNLOCK TABLES точно для того же соединения, чтобы избежать взаимоблокировки.</p>
<p>Чтобы гарантировать использование одного и того же соединения, вы можете обернуть несколько операторов в транзакцию
    . Вот основной шаблон:</p>

<pre><code>type ExampleModel struct {
        DB *sql.DB
    }
    
    func (m *ExampleModel) ExampleTransaction() error {
        
        // Вызов метода Begin() в пуле соединений создает новый
        // объект sql.Tx, который представляет выполняющуюся транзакцию базы данных.
        tx, err := m.DB.Begin()
        
        if err != nil {
            return err
        }
        
        // Вызовите Exec() для транзакции, передав оператору
        // и любые параметры. Важно отметить, что tx.Exec() вызывается
        // для только что созданного объекта транзакции, а НЕ для пула соединений. Хотя здесь мы
        // используем tx.Exec(), вы также можете // использовать tx.Query() и tx.QueryRow()
        // точно таким же образом.
        _, err = tx.Exec("INSERT INTO ...")
        
        if err != nil {
            // Если есть какая-либо ошибка, мы вызываем метод tx.Rollback() для
            // транзакции. Это прервет транзакцию,
            // и в базу данных не будут внесены никакие изменения.
            tx.Rollback()
            return err
        }
        // Выполнить другую транзакцию точно таким же образом.
        _, err = tx.Exec("UPDATE ...")

        if err != nil {
            tx.Rollback()
            return err
        }

        // Если ошибок нет, операторы в транзакции могут быть зафиксированы
        // в базе данных с помощью метода tx.Commit(). Очень важно ВСЕГДА
        // вызывать либо Rollback(), либо Commit() перед возвратом функции. Если вы
        // этого не сделаете, соединение останется открытым и не будет
        // возвращено в пул соединений. Это может привести к превышению максимального
        // лимита подключений/исчерпанию ресурсов.
        err = tx.Commit()
        
        return err
    }</code></pre>

<p>Транзакции также очень полезны, если вы хотите выполнить несколько операторов SQL как одно
    атомарное действие. Пока вы используете метод tx.Rollback() в случае каких-либо
    ошибок, транзакция гарантирует, что:</p>
<ul>
    <li>Все операторы выполняются успешно; или</li>
    <li>Операторы не выполняются, и база данных остается неизменной.</li>
</ul>

<h3>Управление соединениями</h3>
<p>Пул соединений sql.DB состоит из соединений, которые либо простаивают, либо используются. По
    умолчанию максимальное количество открытых соединений (бездействующих + используемых) одновременно не ограничено
    , но максимальное количество незанятых соединений в пуле по умолчанию равно 2. Вы можете изменить эти значения по умолчанию с помощью функций SetMaxOpenConns() и Методы SetMaxIdleConns(). Например:
    </p>

<pre><code>db, err := sql.Open("mysql", *dsn)
    if err != nil {
        log.Fatal(err)
    }

    // Устанавливаем максимальное количество одновременно открытых (бездействующих + используемых)
    // подключений. Установка этого значения меньше или равного 0 будет означать, что максимальный
    // предел отсутствует. Если достигнуто максимальное количество открытых подключений и все они
    // используются, когда требуется новое подключение, Go будет ждать, пока одно из подключений 
    // не освободится и не станет бездействующим. С точки зрения пользователя это означает, что 
    // его HTTP-запрос будет зависать, пока соединение не будет освобождено.
    db.SetMaxOpenConns(100)

    // Устанавливаем максимальное количество простаивающих соединений в пуле. Установка этого
    // значения меньше или равного 0 будет означать, что бездействующие соединения не сохраняются.
    db.SetMaxIdleConns(5)</code></pre>

<p>Использование этих методов сопряжено с одной оговоркой: ваша база данных, вероятно, имеет жесткое ограничение на
    максимальное количество подключений.</p>
<p>Например, ограничение по умолчанию для MySQL равно 151. Таким образом, если оставить SetMaxOpenConns() полностью
    неограниченным или установить для него значение больше 151, ваша база данных будет возвращать
    ошибку «слишком много подключений» при высокой нагрузке. Чтобы предотвратить эту ошибку,
    вам нужно установить максимальное значение открытых подключений ниже 151.
    </p>
<p>Но это, в свою очередь, создает другую проблему. Когда лимит SetMaxOpenConns() достигнут, любые
    новые задачи базы данных, которые необходимо выполнить вашему приложению, будут вынуждены ждать, пока соединение
    не освободится.</p>
<p>Для некоторых приложений такое поведение может быть приемлемым, но в веб-приложении, возможно, лучше
    немедленно зарегистрировать сообщение об ошибке «слишком много подключений» и отправить
    пользователю 500 Internal Server Error, вместо того, чтобы его HTTP-запрос зависал и,
    возможно, тайм-аут ожидание свободного подключения.
    </p>
<p>Вот почему я не использовал методы SetMaxOpenConns() и SetMaxIdleConns() в нашем
    приложении и оставил поведение sql.DB в качестве настроек по умолчанию.
    </p>
<h3>Подготовленные операторы</h3>
<p>Как я упоминал ранее, все методы Exec(), Query() и QueryRow() используют подготовленные
    операторы за кулисами, чтобы помочь предотвратить атаки SQL-инъекций. Они устанавливают подготовленный
    оператор для соединения с базой данных, запускают его с предоставленными параметрами, а затем закрывают
    подготовленный оператор. Это может показаться довольно неэффективным, поскольку мы
    каждый раз создаем и воссоздаем одни и те же подготовленные операторы.
    </p>
<p>Теоретически лучшим подходом могло бы быть использование метода DB.Prepare() для создания
    нашего собственного подготовленного оператора один раз, а затем его повторное использование. Это особенно верно для
    сложных операторов SQL (например, тех, которые имеют несколько JOINS) и повторяются очень часто.
    часто (например, массовая вставка десятков тысяч записей). В этих случаях стоимость повторной подготовки операторов может оказать заметное влияние на время выполнения.
    </p>
<p>Вот базовый шаблон для использования собственного подготовленного оператора в веб-приложении:
</p>
<pre><code>
    // Нам нужно где-то хранить подготовленный оператор на время жизни нашего
    // веб-приложения. Аккуратный способ — встроить его вместе с пулом соединений.
    type ExampleModel struct {
        DB *sql.DB
        InsertStmt *sql.Stmt
    }

    // Создаем конструктор для модели, в котором настраиваем подготовленный
    // оператор.
    func NewExampleModel(db *sql.DB) (*ExampleModel, error) {
        // Используйте метод Prepare, чтобы создать новый подготовленный оператор
        // для текущего пула соединений. Это возвращает объект sql.Stmt,
        // представляющий подготовленный оператор.
        insertStmt, err := db.Prepare("INSERT INTO ...")
        
        if err != nil {
            return nil, err
        }

        // Сохраняем его в нашем объекте ExampleModel вместе с пулом соединений.
        return &ExampleModel{db, insertStmt}, nil
    }

    // Любые методы, реализованные для объекта ExampleModel, будут иметь доступ
    // к подготовленному оператору.    
    func (m *ExampleModel) Insert(args...) error {
        // Обратите внимание, как мы вызываем Exec непосредственно для подготовленного оператора,
        // а не для пула соединений? Подготовленные операторы также поддерживают
        // методы Query и QueryRow.
        _, err := m.InsertStmt.Exec(args...)
        return err
    }
    
    // В основной функции веб-приложения нам потребуется инициализировать новую
    // структуру ExampleModel с помощью функции-конструктора.
    func main() {
        db, err := sql.Open(...)
        if err != nil {
            errorLog.Fatal(err)
        }
        defer db.Close()
        
        // Создаем новый объект ExampleModel, который включает в себя подготовленный оператор.
        exampleModel, err := NewExampleModel(db)
        if err != nil {
            errorLog.Fatal(err)
        }

        // Отложить вызов Close для подготовленного оператора, чтобы убедиться, 
        // что он корректно закрыт перед завершением нашей основной функции.
        defer exampleModel.InsertStmt.Close()
    }</code></pre>

<p>Однако есть несколько вещей, о которых следует опасаться.
</p>
<p>Подготовленные операторы существуют в соединениях с базой данных. Итак, поскольку Go использует пул многих
    соединений с базой данных, на самом деле происходит то, что при первом
    использовании подготовленного оператора (т. е. объекта sql.Stmt) он создается для определенного соединения с базой данных. Затем объект
    sql.Stmt запоминает, какое соединение в пуле использовалось. В следующий раз
    объект sql.Stmt попытается снова использовать то же соединение с базой данных. Если это соединение закрыто или используется (т. е. не простаивает), оператор будет повторно подготовлен для другого
    соединения.</p>
<p>При большой нагрузке возможно создание большого количества подготовленных операторов.
    на нескольких соединениях. Это может привести к тому, что операторы будут готовиться и переподготавливаться чаще,
    чем вы ожидаете, или даже сталкиваться с ограничениями на стороне сервера на количество
    операторов (в MySQL максимальное количество подготовленных операторов по умолчанию составляет 16 382).
    </p>
<p>Код также сложнее, чем без использования подготовленных операторов.
</p>
<p>Таким образом, необходимо найти компромисс между производительностью и сложностью. Как и в любом другом случае,
    вы должны измерить фактическую выгоду от реализации ваших собственных подготовленных
    операторов, чтобы определить, стоит ли это делать. В большинстве случаев я бы предположил, что использование
    обычных методов Query(), QueryRow() и Exec() — без самостоятельной подготовки операторов
    — является разумной отправной точкой.</p>


<p>Конец главы 4.</p>


</body>
</html>