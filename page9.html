<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 3</title>
</head>
<body>
    <h1>Конфигурация и обработка ошибок</h1>
<p>В этом разделе книги мы собираемся заняться домашним хозяйством. На самом деле мы не будем добавлять
    много новых функций в наше приложение, а вместо этого сосредоточимся на внесении улучшений
    , которые облегчат управление по мере его роста.</p>
<p>Вы узнаете, как:</p>
<ul>
    <li>Установите параметры конфигурации для вашего приложения во время выполнения простым и идиоматичным способом,
        используя флаги командной строки.</li>
    <li>Улучшите сообщения журнала приложений, чтобы они содержали больше информации, и управляйте ими
        по-разному в зависимости от типа (или уровня) сообщения журнала.
    </li>
    <li>Сделайте зависимости доступными для ваших обработчиков таким образом, чтобы они были расширяемыми, типобезопасными и
        не мешали написанию тестов.</li>
    <li>Централизованная обработка ошибок, чтобы вам не приходилось повторяться при написании кода.
    </li>
</ul>
<h2>Управление параметрами конфигурации</h2>
<p>Файл main.go нашего веб-приложения в настоящее время содержит несколько жестко запрограммированных
    параметров конфигурации:</p>
<ul>
    <li>Сетевой адрес сервера для прослушивания (в настоящее время ":4000")
    </li>
    <li>Путь к файлу для каталога статических файлов (в настоящее время "./ ui/static")
    </li>
</ul>
<p>Жестко запрограммировать их не идеально. Между нашими настройками конфигурации и кодом нет разделения
    , и мы не можем изменить настройки во время выполнения (что важно, если вам
    нужны разные настройки для среды разработки, тестирования и производственной среды).
</p>
<p>В этой главе мы начнем улучшать это и сделаем сетевой адрес нашего сервера
    настраиваемым во время выполнения.</p>
<h2>Флаги командной строки</h2>
    <p>В Go распространенный и идиоматический способ управления параметрами конфигурации — использование флагов командной строки при запуске приложения. Например:</p>
<pre><code>$ go run ./cmd/web -addr=":80"</code></pre>
<p>Самый простой способ принять и проанализировать флаг командной строки из вашего приложения — это использовать
    строку кода, подобную этой:</p>
<pre><code>addr := flag.String("addr", ":4000", "HTTP network address")</code></pre>
<p>По сути, это определяет новый флаг командной строки с именем addr, значением по умолчанию
    «: 4000» и небольшим текстом справки, объясняющим, что контролирует этот флаг. Значение флага
    будет сохранено в переменной addr во время выполнения.
</p>
<p>Давайте воспользуемся этим в нашем приложении и заменим жестко запрограммированный сетевой адрес флагом
    командной строки:
</p>
<pre><code>File: cmd/web/main.go
    package main
    import (
    "flag" // New import
    "log"
    "net/http"
    )
    func main() {
    // Define a new command-line flag with the name 'addr', a default value of ":4000"
    // and some short help text explaining what the flag controls. The value of the
    // flag will be stored in the addr variable at runtime.
    addr := flag.String("addr", ":4000", "HTTP network address")
    // Importantly, we use the flag.Parse() function to parse the command-line flag.
    // This reads in the command-line flag value and assigns it to the addr
    // variable. You need to call this *before* you use the addr variable
    // otherwise it will always contain the default value of ":4000". If any errors are
    // encountered during parsing the application will be terminated.
    flag.Parse()
    mux := http.NewServeMux()
    mux.HandleFunc("/", home)
    mux.HandleFunc("/snippet", showSnippet)
    mux.HandleFunc("/snippet/create", createSnippet)
    fileServer := http.FileServer(http.Dir("./ui/static/"))
    mux.Handle("/static/", http.StripPrefix("/static", fileServer))
    // The value returned from the flag.String() function is a pointer to the flag
    // value, not the value itself. So we need to dereference the pointer (i.e.
    // prefix it with the * symbol) before using it. Note that we're using the
    // log.Printf() function to interpolate the address with the log message.
    log.Printf("Starting server on %s", *addr)
    err := http.ListenAndServe(*addr, mux)
    log.Fatal(err)
}</code></pre>
<p>Сохраните этот файл и попробуйте использовать флаг -addr при запуске приложения. Вы должны обнаружить
    , что сервер теперь прослушивает любой указанный вами адрес, например:</p>
<pre><code>$ go run ./cmd/web -addr=":9999"
    2023/08/08 19:15:47 Starting server on :9999</code></pre>
<p class="box-field">Примечание. Порты 0–1023 ограничены и (как правило) могут использоваться только службами с
    привилегиями root. Если вы попытаетесь использовать один из этих портов, вы должны получить
    сообщение об ошибке привязки: разрешение запрещено при запуске.</p>
<h2>Значения по умолчанию</h2>
<p>Флаги командной строки совершенно необязательны. Например, если вы запустите приложение без
    флага -addr, сервер вернется к прослушиванию по адресу: 4000 (это
    значение по умолчанию, которое мы указали).</p>
<pre><code>$ go run ./cmd/web
    2023/08/08 19:28:11 Starting server on :4000</code></pre>

<p>Нет никаких правил о том, что использовать в качестве значений по умолчанию для ваших флагов командной строки. Мне
    нравится использовать значения по умолчанию, которые имеют смысл для моей среды разработки, потому что это экономит
    время и трудозатраты при создании приложения. Но ЮММВ. Вместо этого вы можете предпочесть более безопасный
    подход к установке значений по умолчанию для вашей производственной среды.</p>
<h2>Преобразования типов</h2>
<p>В приведенном выше коде мы использовали функцию flag.String() для определения флага командной строки.
    Преимущество этого заключается в преобразовании любого значения, которое пользователь предоставляет во время выполнения, в строковый
    тип. Если значение не может быть преобразовано в строку, приложение регистрирует ошибку и
    завершает работу.</p>
<p>Go также имеет ряд других функций, включая flag.Int(), flag.Bool() и
    flag.Float64(). Они работают точно так же, как flag.String(), за исключением того, что они
    автоматически преобразуют значение флага командной строки в соответствующий тип.
</p>
<h2>Автоматизированная справка</h2>
<p>Еще одна замечательная функция заключается в том, что вы можете использовать флаг -help для отображения всех доступных флагов командной строки для приложения и сопровождающего их текста справки. Попробуйте:</p>
<pre><code>$ go run ./cmd/web -help
    Usage of /tmp/go-build786121279/b001/exe/handlers:
    -addr string
    HTTP network address (default ":4000")</code></pre>
<p>Итак, в целом, это начинает выглядеть действительно хорошо. Мы представили идиоматический способ
    управления параметрами конфигурации нашего приложения во время выполнения, а также получили
    явный и документированный интерфейс между нашим приложением и его рабочей конфигурацией.
</p>
<h2>Дополнительная информация</h2>
<h3>Переменные среды</h3>
<p>Если вы уже создавали и развертывали веб-приложения, вы, вероятно, думаете
    о переменных среды? Конечно, хранить
    там настройки конфигурации — это хорошая практика?</p>
<p>Если вы хотите, вы можете сохранить настройки конфигурации в переменных среды и получить к
    ним доступ непосредственно из вашего приложения с помощью функции os.Getenv() следующим образом:
</p>
<pre>
    <code>addr := os.Getenv("SNIPPETBOX_ADDR")</code>
</pre>
<p>Но у этого есть некоторые недостатки по сравнению с использованием флагов командной строки. Вы не можете указать
    настройку по умолчанию (возвращаемое значение из os.Getenv() является пустой строкой, если переменная среды
    не существует), вы не получаете функциональность -help, которую вы делаете с флагами командной строки, и возвращаемое значение из os.Getenv() всегда является строкой. Вы не получаете автоматических
    преобразований типов, как в случае с flag.Int() и другими функциями флагов командной строки.
</p>
<p>Вместо этого вы можете получить лучшее из обоих миров, передав переменную среды в качестве
    флага командной строки при запуске приложения. Например:
</p>
<pre><code>$ export SNIPPETBOX_ADDR=":9999"
    $ go run ./cmd/web -addr=$SNIPPETBOX_ADDR
    2018/08/08 19:45:29 Starting server on :9999</code></pre>

<h2>Логические флаги</h2>    
<p>Для флагов, определенных с помощью flag.Bool(), пропуск значения аналогичен написанию -flag=true. Следующие
 две команды эквивалентны:</p>
 <pre><code>$ go run example.go -flag=true
    $ go run example.go -flag</code></pre>   
 <p>Вы должны явно использовать -flag=false, если хотите установить значение логического флага в false.</p>   
<h2>Существующие переменные</h2>
<p>Можно преобразовать значения флагов командной строки в адреса памяти уже существующих переменных, используя функции
    flag.StringVar(), flag.IntVar(), flag.BoolVar() и другие .
    Это может быть полезно, если вы хотите хранить все параметры конфигурации в одной
    структуре. В качестве грубого примера:
</p>
 <pre><code>type Config struct {
    Addr string
    StaticDir string
    }
    ...
    cfg := new(Config)
    flag.StringVar(&cfg.Addr, "addr", ":4000", "HTTP network address")
    flag.StringVar(&cfg.StaticDir, "static-dir", "./ui/static", "Path to static assets")
    flag.Parse()</code></pre>
<p>На данный момент в нашем файле main.go мы выводим сообщения журнала, используя
    функции log.Printf() и log.Fatal().
    Обе эти функции выводят сообщения через стандартный регистратор Go, который по умолчанию
    добавляет к сообщениям префикс с локальной датой и временем и записывает их в стандартный
    поток ошибок (который должен отображаться в окне терминала). Функция log.Fatal() также вызовет
    os.Exit(1) после написания сообщения, что приведет к немедленному завершению работы приложения.
    Мы можем разделить наши сообщения журнала на два различных типа или уровня. Первый тип —
    информационные сообщения (например, «Запуск сервера в: 4000»), а второй тип —
    сообщения об ошибках.</p>
<pre>
    <code>log.Printf("Starting server on %s", *addr) // Information message
        err := http.ListenAndServe(*addr, mux)
        log.Fatal(err) // Error message</code>
</pre>
<p>Давайте улучшим наше приложение, добавив возможность ведения журналов по уровням, чтобы
    информация и сообщения об ошибках обрабатывались немного по-другому. В частности:
    мы добавим к информационным сообщениям префикс «INFO» и выведем сообщение на стандартный
    вывод (stdout).
    Мы добавим к сообщениям об ошибках префикс «ERROR» и выведем их в стандартную ошибку (stderr)
    вместе с соответствующим именем файла и номером строки, вызывающей регистратор (для помощи в
    отладке).
    Есть несколько разных способов сделать это, но простой и понятный подход — использовать
    функцию log.New() для создания двух новых пользовательских регистраторов.
<pre><code>File: cmd/web/main.go
    package main
    import (
    "flag"
    "log"
    "net/http"
    "os" // New import
    )
    func main() {
    addr := flag.String("addr", ":4000", "HTTP network address")
    flag.Parse()
    // Use log.New() to create a logger for writing information messages. This takes
    // three parameters: the destination to write the logs to (os.Stdout), a string
    // prefix for message (INFO followed by a tab), and flags to indicate what
    // additional information to include (local date and time). Note that the flags
    // are joined using the bitwise OR operator |.
    infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
    // Create a logger for writing error messages in the same way, but use stderr as
    // the destination and use the log.Lshortfile flag to include the relevant
    // file name and line number.
    errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
    mux := http.NewServeMux()
    mux.HandleFunc("/", home)
    mux.HandleFunc("/snippet", showSnippet)
    mux.HandleFunc("/snippet/create", createSnippet)
    fileServer := http.FileServer(http.Dir("./ui/static/"))
    mux.Handle("/static/", http.StripPrefix("/static", fileServer))
    // Write messages using the two new loggers, instead of the standard logger.
    infoLog.Printf("Starting server on %s", *addr)
    err := http.ListenAndServe(*addr, mux)
    errorLog.Fatal(err)
}</code></pre>
<p>Хорошо… давайте попробуем это!
    Запустите приложение, затем откройте другое окно терминала и попробуйте запустить его во
    второй раз. Это должно вызвать ошибку, потому что сетевой адрес, который хочет
    прослушивать наш сервер (":4000"), уже используется.
    Вывод журнала во втором терминале должен выглядеть примерно так:</p>

<pre><code>$ go run ./cmd/web
    INFO 2018/08/09 20:10:43 Starting server on :4000
    ERROR 2018/08/09 20:10:43 main.go:30: listen tcp :4000: bind: address already in use
    exit status 1</code></pre>
<p>Обратите внимание, что два сообщения имеют разные префиксы, чтобы их можно было легко различить в терминале, а наше сообщение об ошибке также включает имя файла и номер строки (main.go:30), которая вызвала регистратор?</p>

<p class="box-field">Совет. Если вы хотите включить в вывод журнала полный путь к файлу, а не только
    имя файла, вы можете использовать флаг log.Llongfile вместо log.Lshortfile при создании пользовательского регистратора. Вы также можете заставить свой регистратор использовать дату и время UTC (вместо
    локальных), добавив флаг log.LUTC.</p>
    <h2>Раздельное ведение журнала</h2>
    <p>Большим преимуществом ведения журнала ваших сообщений в стандартные потоки (stdout и stderr), как у нас,является то, что ваше приложение и ведение журнала не связаны. Само ваше приложение не связано с маршрутизацией или хранением журналов, и это может упростить управление журналами по-разному в зависимости от среды.</p>
    <p>Во время разработки легко просматривать вывод журнала, поскольку в терминале отображаются стандартные потоки.</p>
    <p>В промежуточных или производственных средах вы можете перенаправить потоки в конечный пункт назначения для просмотра и архивирования. Это место назначения может быть файлами на диске или службой ведения журналов, такой как Splunk. В любом случае конечный пункт назначения журналов может управляться вашим выполнением среды независимо от приложения.
    Например, мы могли бы перенаправить потоки stdout и stderr в файлы на диске при запускеприложения следующим образом:</p>
<pre><code>$ go run ./cmd/web >>/tmp/info.log 2>>/tmp/error.log</code></pre>
<p class="box-field">Примечание. Использование двойной стрелки >> добавит существующий файл, а не обрежет его при запуске приложения.</p>
<h2>Журнал ошибок http.Server</h2>
<p>Есть еще одно изменение, которое нам нужно внести в наше приложение. По умолчанию, если HTTP-
    сервер Go обнаруживает ошибку, он регистрирует ее с помощью стандартного регистратора. Для согласованности было бы
    лучше использовать вместо этого наш новый регистратор errorLog.</p>
<p>Чтобы это произошло, нам нужно инициализировать новую структуру http.Server, содержащую параметры конфигурации для нашего сервера, вместо использования ярлыка http.ListenAndServe().</p>
<p>Вероятно, проще всего продемонстрировать это:</p>

<pre>
    <code>File: cmd/web/main.go
        package main
        ...
        func main() {
        addr := flag.String("addr", ":4000", "HTTP network address")
        flag.Parse()
        infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
        errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
        mux := http.NewServeMux()
        mux.HandleFunc("/", home)
        mux.HandleFunc("/snippet", showSnippet)
        mux.HandleFunc("/snippet/create", createSnippet)
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Handle("/static/", http.StripPrefix("/static", fileServer))
        // Initialize a new http.Server struct. We set the Addr and Handler fields so
        // that the server uses the same network address and routes as before, and set
        // the ErrorLog field so that the server now uses the custom errorLog logger in
        // the event of any problems.
        srv := &http.Server{
        Addr: *addr,
        ErrorLog: errorLog,
        Handler: mux,
        }
        infoLog.Printf("Starting server on %s", *addr)
        // Call the ListenAndServe() method on our new http.Server struct.
        err := srv.ListenAndServe()
        errorLog.Fatal(err)
    }</code>
</pre>
<h2>Дополнительная информация</h2>
<h3>Дополнительные методы журналирования</h3>
<p>До сих пор в этой книге мы использовали методы Println(), Printf() и Fatal() для записи
    сообщений журнала, но Go предоставляет ряд других методов,
    с которыми стоит ознакомиться.</p>
<p>Как правило, вам следует избегать использования вариантов Panic() и Fatal() за пределами
    вашей функции main() — вместо этого рекомендуется возвращать ошибки и использовать только panic или выход
    непосредственно из main().</p>
<h2>Параллельное ведение журнала</h2>
<p>Пользовательские регистраторы, созданные с помощью log.New(), защищены от параллелизма. Вы можете совместно использовать один регистратор
    и использовать его в нескольких горутинах и в своих обработчиках, не беспокоясь о
    состоянии гонки.
</p>
<p>Тем не менее, если у вас есть несколько регистраторов, записывающих в одно и то же место назначения, вам нужно быть
    осторожным и убедиться, что базовый метод Write() места назначения также безопасен для
    одновременного использования.
</p>    
<h2>Регистрация в файл</h2>
<p>Как я уже говорил выше, моя общая рекомендация состоит в том, чтобы записывать ваш вывод в стандартные потоки и
    перенаправлять вывод в файл во время выполнения. Но если вы не хотите этого делать, вы всегда можете открыть
    файл в Go и использовать его в качестве места назначения журнала. В качестве грубого примера:
</p>
<pre><code>f, err := os.OpenFile("/tmp/info.log", os.O_RDWR|os.O_CREATE, 0666)
if err != nil {
    log.Fatal(err)
}
defer f.Close()
infoLog := log.New(f, "INFO\t", log.Ldate|log.Ltime)
</code></pre>

</body>
</html>