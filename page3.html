<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 2</title>
</head>
<body>   
<h1>Основы веб-приложения</h1>
<p>Теперь, когда все настроено правильно, давайте сделаем первую итерацию нашего веб-приложения.
    Мы начнем с трех абсолютно необходимых вещей:</p>    
    <li>Первое, что нам нужно, это обработчик. Если вы исходите из MVC-фона, вы можете
        думать об обработчиках как о чем-то вроде контроллеров. Они отвечают за выполнение
        логики вашего приложения и за написание заголовков и тел ответов HTTP.</li>
    <li>Второй компонент — маршрутизатор (или servemux в терминологии Go). В нем хранится
        сопоставление между шаблонами URL для вашего приложения и соответствующими
        обработчиками. Обычно у вас есть один servermux для вашего приложения, содержащий все ваши маршруты.</li>
    <li>Последнее, что нам нужно, это веб-сервер. Одна из замечательных особенностей Go заключается в том, что вы можете
        установить веб-сервер и прослушивать входящие запросы как часть вашего приложения.
        Вам не нужен внешний сторонний сервер, такой как Nginx или Apache.</li>
<p>Давайте объединим эти компоненты в файл main.go, чтобы создать работающее приложение.</p>
    
<pre><code>File: main.go
    package main
    import (
    "log"
    "net/http"
    )
    // Define a home handler function which writes a byte slice containing
    // "Hello from Snippetbox" as the response body.
    func home(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("Hello from Snippetbox"))
    }
    func main() {
    // Use the http.NewServeMux() function to initialize a new servemux, then
    // register the home function as the handler for the "/" URL pattern.
    mux := http.NewServeMux()
    mux.HandleFunc("/", home)
    // Use the http.ListenAndServe() function to start a new web server. We pass in
    // two parameters: the TCP network address to listen on (in this case ":4000")
    // and the servemux we just created. If http.ListenAndServe() returns an error
    // we use the log.Fatal() function to log the error message and exit. Note
    // that any error returned by http.ListenAndServe() is always non-nil.
    log.Println("Starting server on :4000")
    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}</code></pre>    
<p class="box-field">Примечание. Функция домашнего обработчика — это обычная функция Go с двумя параметрами.
    Параметр <span>http.ResponseWriter</span> предоставляет методы для сборки
    ответа HTTP и отправки его пользователю, а параметр <span>*http.Request</span> представляет собой указатель на
    структуру, которая содержит информацию о текущем запросе (например, метод HTTP
    и запрашиваемый URL-адрес). . Мы еще поговорим об этих параметрах и
    продемонстрируем, как их использовать, по ходу чтения книги.</p>  
<p>Когда вы запускаете этот код, он должен запускать веб-сервер, прослушивающий порт 4000 вашего локального
    компьютера. Каждый раз, когда сервер получает новый HTTP-запрос, он передает запрос на
    servermux, а servermux, в свою очередь, проверяет URL-путь и отправляет запрос
    соответствующему обработчику.</p>
<p>Давайте попробуем. Сохраните файл main.go, а затем попробуйте запустить его из терминала
    с помощью команды go run.</p>    
 
<pre><code>$ cd $HOME/code/snippetbox
    $ go run main.go
    2023/08/02 10:08:07 Starting server on :4000</code></pre>    
<p>Пока сервер работает, откройте веб-браузер и попробуйте посетить http://localhost:4000. Если
    все прошло по плану, вы должны увидеть страницу, которая выглядит примерно так:</p>
<p><img src="static/images/picture2.2.png"/></p>
<p class="box-field">Важно: прежде чем мы продолжим, я должен объяснить, что servermux Go обрабатывает
    шаблон URL «/» как универсальный. Таким образом, на данный момент все HTTP-запросы к нашему серверу будут
    обрабатываться домашней функцией, независимо от их URL-пути. Например, вы можете посетить
    другой URL-адрес, такой как http://localhost:4000/foo, и вы получите точно такой
    же ответ.</p>
<p>Если вы вернетесь в окно терминала, вы можете остановить сервер, нажав Ctrl+c на
    клавиатуре.</p>
<h2>Дополнительная информация</h2>
<h3>Сетевые адреса</h3>    
 <p>Сетевой адрес TCP, который вы передаете в http.ListenAndServe(), должен иметь формат
    «хост:порт». Если вы опустите хост (как мы сделали с «: 4000»), сервер будет прослушивать все
    доступные сетевые интерфейсы вашего компьютера. Как правило, вам нужно указать хост в
    адресе только в том случае, если ваш компьютер имеет несколько сетевых интерфейсов и вы хотите прослушивать только
    один из них.</p>   
<p> В других проектах или документации Go вы можете иногда видеть сетевые адреса, написанные
    с использованием именованных портов, таких как «: http» или «: http-alt» вместо числа. Если вы используете именованный
    порт, Go попытается найти соответствующий номер порта в вашем файле /etc/services.
    при запуске сервера или вернет ошибку, если совпадение не может быть найдено.</p>    
<h3>Использование команды go run</h3>   
<p>Во время разработки команда go run является удобным способом опробовать ваш код. По сути, это
    ярлык, который компилирует ваш код, создает исполняемый двоичный файл в вашем
    каталоге /tmp, а затем запускает этот двоичный файл за один шаг.</p>    
<p>Он принимает либо список файлов .go, разделенных пробелами, либо путь к определенному пакету (где
    символ . представляет ваш текущий каталог), либо полный путь к модулю. Для нашего
    приложения на данный момент все три следующие команды эквивалентны:</p>    
<pre><code>$ go run main.go
    $ go run .
    $ go run turamant.net/snippetbox
</code></pre>   
</body>
</html>