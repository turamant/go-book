<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 5</title>
</head>
<body>
    <nav>
        <ul>
            <li><a href="page1.html">page1</a></li>
            <li><a href="page2.html">page2</a></li>
            <li><a href="page3.html">page3</a></li>
            <li><a href="page4.html">page4</a></li>
            <li><a href="page5.html">page5</a></li>
            <li><a href="page6.html">page6</a></li>
            <li><a href="page7.html">page7</a></li>
            <li><a href="page8.html">page8</a></li>
            <li><a href="page9.html">page9</a></li>
            <li><a href="page10.html">page10</a></li>
        </ul>
    </nav>
<h1>Глава 6. Программное обеспечение промежуточного слоя</h1>
<p>При создании веб-приложения, вероятно, есть некоторые общие функции, которые
    вы хотите использовать для многих (или даже для всех) HTTP-запросов. Например, вы можете захотеть регистрировать
    каждый запрос, сжимать каждый ответ или проверять кеш перед передачей запроса
    вашим обработчикам.</p>
<p>Распространенным способом организации этой общей функциональности является установка ее в качестве промежуточного программного обеспечения. По сути, это
    некоторый автономный код, который независимо действует на запрос до или после
    ваших обычных обработчиков приложений.</p>
<p>В этом разделе книги вы узнаете:</p>
<ul>
    <li>Идиоматический шаблон для создания и использования пользовательского промежуточного программного обеспечения, совместимого
        с net/http и многими сторонними пакетами.</li>
    <li>Как создать промежуточное ПО, которое устанавливает полезные заголовки безопасности для каждого ответа HTTP.
    </li>
    <li>Как создать промежуточное ПО, которое регистрирует запросы, полученные вашим приложением.
    </li>
    <li>Как создать промежуточное ПО, которое восстанавливает паники, чтобы ваше приложение изящно обрабатывало их.</li>
    <li>Как создавать и использовать компонуемые цепочки промежуточного ПО для управления и организации
        промежуточного ПО.</li>
</ul>
<h2>Глава 6.1. Как работает ПО промежуточного слоя</h2>
<p>Ранее в этой книге я сказал кое-что, что хотел бы развить в этой главе:
</p>
<p>«Веб-приложение Go можно представить как цепочку методов ServeHTTP(), вызываемых один
    за другим».</p>
<p>В настоящее время в нашем приложении, когда наш сервер получает новый HTTP-запрос, он вызывает
    метод ServeHTTP() сервисмультиплексора. Это ищет соответствующий обработчик на основе
    пути URL-адреса запроса и, в свою очередь, вызывает метод ServeHTTP() этого обработчика.
    </p>
<p>Основная идея промежуточного программного обеспечения состоит в том, чтобы вставить в эту цепочку еще один обработчик. Обработчик промежуточного слоя
    выполняет некоторую логику, например регистрирует запрос, а затем вызывает метод ServeHTTP()
    следующего обработчика в цепочке.</p>
<p>На самом деле, мы уже используем некоторое промежуточное программное обеспечение в нашем приложении —
    функцию http.StripPrefix() для обслуживания статических файлов, которая удаляет определенный префикс из
    URL-пути запроса перед передачей запроса на файловый сервер.
    </p>
<h3>Шаблон</h3>
<p>Стандартный шаблон для создания собственного промежуточного ПО выглядит следующим образом:
</p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, r *http.Request) {
    // TODO: Execute our middleware logic here...
    next.ServeHTTP(w, r)
    }
    return http.HandlerFunc(fn)
}</code></pre>
<p>Сам код довольно лаконичен, но в нем довольно много всего, что нужно для размышлений.
</p>
<ul>
    <li>Функция myMiddleware() по существу представляет собой оболочку для следующего обработчика.
    </li>
    <li>Он устанавливает функцию fn, которая замыкает следующий обработчик, чтобы сформировать замыкание. Когда
        fn запускается, он выполняет нашу логику промежуточного программного обеспечения, а затем передает управление следующему обработчику,
        вызывая его метод ServeHTTP().</li>
    <li>Независимо от того, что вы делаете с замыканием, оно всегда будет иметь доступ к переменным
        , которые являются локальными для области, в которой оно было создано, что в данном случае означает, что fn
        всегда будет иметь доступ к следующей переменной.</li>
    <li>Затем мы преобразуем это замыкание в http.Handler и возвращаем его с помощью
        адаптера http.HandlerFunc().</li>
</ul>
<p>Если это кажется запутанным, вы можете думать об этом проще: myMiddleware — это функция, которая
    принимает следующий обработчик в цепочке в качестве параметра. Он возвращает обработчик, который выполняет
    некоторую логику, а затем вызывает следующий обработчик.</p>

<h3>Simplifying the Middleware</h3>
<p>Изменением этого шаблона является использование анонимной функции для перезаписи
    промежуточного программного обеспечения myMiddleware следующим образом:</p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // TODO: Execute our middleware logic here...
    next.ServeHTTP(w, r)
    })
}</code></pre>
<p>Этот шаблон очень распространен в дикой природе, и вы, вероятно, будете видеть его чаще всего, если
    читаете исходный код других приложений или сторонних пакетов.</p>
<h3>Позиционирование ПО промежуточного слоя</h3>
<p>Важно объяснить, что расположение ПО промежуточного слоя в цепочке обработчиков
    будет влиять на поведение вашего приложения.</p>
<p>Если вы поместите свое промежуточное ПО в цепочку перед servermux, оно будет действовать на каждый
    запрос, который получает ваше приложение.</p>
<pre><code>myMiddleware → servemux → application handler</code></pre>
<p>Хорошим примером того, где это было бы полезно, является ПО промежуточного слоя для регистрации запросов, поскольку
    обычно это то, что вы хотели бы делать для всех запросов.</p>
<p>В качестве альтернативы вы можете расположить промежуточное ПО после servermux в цепочке,
    обернув определенный обработчик приложения. Это приведет к тому, что ваше промежуточное ПО будет
    выполняться только для определенных маршрутов.</p>
<pre><code>servemux → myMiddleware → application handler</code></pre>
<p>Примером этого может быть что-то вроде промежуточного программного обеспечения авторизации, которое вы можете
    запускать только на определенных маршрутах.</p>
<p>Мы продемонстрируем, как сделать обе эти вещи на практике, по ходу чтения книги.</p>

<h2>Chapter 6.2.
    Setting Security Headers</h2>








<p>Конец главы 5.</p>
</body>
</html>