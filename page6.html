<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 6</title>
</head>
<body>
    <nav>
        <ul>
            <li><a href="page1.html">page1</a></li>
            <li><a href="page2.html">page2</a></li>
            <li><a href="page3.html">page3</a></li>
            <li><a href="page4.html">page4</a></li>
            <li><a href="page5.html">page5</a></li>
            <li><a href="page6.html">page6</a></li>
            <li><a href="page7.html">page7</a></li>
            <li><a href="page8.html">page8</a></li>
            <li><a href="page9.html">page9</a></li>
            <li><a href="page10.html">page10</a></li>
        </ul>
    </nav>
<h1>Глава 6. Программное обеспечение промежуточного слоя</h1>
<p>При создании веб-приложения, вероятно, есть некоторые общие функции, которые
    вы хотите использовать для многих (или даже для всех) HTTP-запросов. Например, вы можете захотеть регистрировать
    каждый запрос, сжимать каждый ответ или проверять кеш перед передачей запроса
    вашим обработчикам.</p>
<p>Распространенным способом организации этой общей функциональности является установка ее в качестве промежуточного программного обеспечения. По сути, это
    некоторый автономный код, который независимо действует на запрос до или после
    ваших обычных обработчиков приложений.</p>
<p>В этом разделе книги вы узнаете:</p>
<ul>
    <li>Идиоматический шаблон для создания и использования пользовательского промежуточного программного обеспечения, совместимого
        с net/http и многими сторонними пакетами.</li>
    <li>Как создать промежуточное ПО, которое устанавливает полезные заголовки безопасности для каждого ответа HTTP.
    </li>
    <li>Как создать промежуточное ПО, которое регистрирует запросы, полученные вашим приложением.
    </li>
    <li>Как создать промежуточное ПО, которое восстанавливает паники, чтобы ваше приложение изящно обрабатывало их.</li>
    <li>Как создавать и использовать компонуемые цепочки промежуточного ПО для управления и организации
        промежуточного ПО.</li>
</ul>
<h2>Глава 6.1. Как работает ПО промежуточного слоя</h2>
<p>Ранее в этой книге я сказал кое-что, что хотел бы развить в этой главе:
</p>
<p>«Веб-приложение Go можно представить как цепочку методов ServeHTTP(), вызываемых один
    за другим».</p>
<p>В настоящее время в нашем приложении, когда наш сервер получает новый HTTP-запрос, он вызывает
    метод ServeHTTP() сервисмультиплексора. Это ищет соответствующий обработчик на основе
    пути URL-адреса запроса и, в свою очередь, вызывает метод ServeHTTP() этого обработчика.
    </p>
<p>Основная идея промежуточного программного обеспечения состоит в том, чтобы вставить в эту цепочку еще один обработчик. Обработчик промежуточного слоя
    выполняет некоторую логику, например регистрирует запрос, а затем вызывает метод ServeHTTP()
    следующего обработчика в цепочке.</p>
<p>На самом деле, мы уже используем некоторое промежуточное программное обеспечение в нашем приложении —
    функцию http.StripPrefix() для обслуживания статических файлов, которая удаляет определенный префикс из
    URL-пути запроса перед передачей запроса на файловый сервер.
    </p>
<h3>Шаблон</h3>
<p>Стандартный шаблон для создания собственного промежуточного ПО выглядит следующим образом:
</p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, r *http.Request) {
    // TODO: Execute our middleware logic here...
    next.ServeHTTP(w, r)
    }
    return http.HandlerFunc(fn)
}</code></pre>
<p>Сам код довольно лаконичен, но в нем довольно много всего, что нужно для размышлений.
</p>
<ul>
    <li>Функция myMiddleware() по существу представляет собой оболочку для следующего обработчика.
    </li>
    <li>Он устанавливает функцию fn, которая замыкает следующий обработчик, чтобы сформировать замыкание. Когда
        fn запускается, он выполняет нашу логику промежуточного программного обеспечения, а затем передает управление следующему обработчику,
        вызывая его метод ServeHTTP().</li>
    <li>Независимо от того, что вы делаете с замыканием, оно всегда будет иметь доступ к переменным
        , которые являются локальными для области, в которой оно было создано, что в данном случае означает, что fn
        всегда будет иметь доступ к следующей переменной.</li>
    <li>Затем мы преобразуем это замыкание в http.Handler и возвращаем его с помощью
        адаптера http.HandlerFunc().</li>
</ul>
<p>Если это кажется запутанным, вы можете думать об этом проще: myMiddleware — это функция, которая
    принимает следующий обработчик в цепочке в качестве параметра. Он возвращает обработчик, который выполняет
    некоторую логику, а затем вызывает следующий обработчик.</p>

<h3>Simplifying the Middleware</h3>
<p>Изменением этого шаблона является использование анонимной функции для перезаписи
    промежуточного программного обеспечения myMiddleware следующим образом:</p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // TODO: Execute our middleware logic here...
    next.ServeHTTP(w, r)
    })
}</code></pre>
<p>Этот шаблон очень распространен в дикой природе, и вы, вероятно, будете видеть его чаще всего, если
    читаете исходный код других приложений или сторонних пакетов.</p>
<h3>Позиционирование ПО промежуточного слоя</h3>
<p>Важно объяснить, что расположение ПО промежуточного слоя в цепочке обработчиков
    будет влиять на поведение вашего приложения.</p>
<p>Если вы поместите свое промежуточное ПО в цепочку перед servermux, оно будет действовать на каждый
    запрос, который получает ваше приложение.</p>
<pre><code>myMiddleware → servemux → application handler</code></pre>
<p>Хорошим примером того, где это было бы полезно, является ПО промежуточного слоя для регистрации запросов, поскольку
    обычно это то, что вы хотели бы делать для всех запросов.</p>
<p>В качестве альтернативы вы можете расположить промежуточное ПО после servermux в цепочке,
    обернув определенный обработчик приложения. Это приведет к тому, что ваше промежуточное ПО будет
    выполняться только для определенных маршрутов.</p>
<pre><code>servemux → myMiddleware → application handler</code></pre>
<p>Примером этого может быть что-то вроде промежуточного программного обеспечения авторизации, которое вы можете
    запускать только на определенных маршрутах.</p>
<p>Мы продемонстрируем, как сделать обе эти вещи на практике, по ходу чтения книги.</p>

<h2>Глава 6.2. Настройка заголовков безопасности</h2>
<p>Давайте воспользуемся шаблоном, который мы изучили в предыдущей главе, и создадим наше собственное
    промежуточное ПО, которое автоматически добавляет следующие два заголовка HTTP к каждому ответу:
</p>
<pre><code>X-Frame-Options: deny
X-XSS-Protection: 1; mode=block</code></pre>
<p>Если вы не знакомы с этими заголовками, они, по сути, предписывают веб-браузеру пользователя реализовать
    некоторые дополнительные меры безопасности, чтобы помочь предотвратить
    атаки XSS и Clickjacking. Рекомендуется включать их, если у вас нет особой причины
    этого не делать.
    Давайте начнем с создания нового файла middleware.go, который мы будем использовать для хранения всего пользовательского
    промежуточного программного обеспечения, которое мы будем писать в этой книге</p>
<pre><code class="terminal">$ touch cmd/web/middleware.go</code></pre>
<p>Затем откройте его и добавьте функцию secureHeaders(), используя шаблон, который мы представили
    в предыдущей главе:</p>
<pre><code>File: cmd/web/middleware.go

    package main
    
    import (
        "net/http"
    )

    func secureHeaders(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("X-XSS-Protection", "1; mode=block")
            w.Header().Set("X-Frame-Options", "deny")
            next.ServeHTTP(w, r)
        })
    }</code></pre>
<p>Поскольку мы хотим, чтобы это промежуточное программное обеспечение действовало на каждый полученный запрос, нам нужно, чтобы оно выполнялось
    до того, как запрос попадет в наш сервисмультиплексор. Мы хотим, чтобы поток управления через наше
    приложение выглядел так:</p>

<pre><code>secureHeaders → servemux → application handler</code></pre>
<p>Для этого нам понадобится промежуточная функция secureHeaders, чтобы обернуть наш сервермультиплексор. Давайте
    обновим файл route.go, чтобы сделать именно это:</p>
<pre><code>File: cmd/web/routes.go

    package main
    
    import "net/http"
    
    // Обновите сигнатуру метода route(), чтобы он
    // возвращал http.Handler вместо *http.ServeMux.
    func (app *application) routes() http.Handler {
        mux := http.NewServeMux()
        mux.HandleFunc("/", app.home)
        mux.HandleFunc("/snippet", app.showSnippet)
        mux.HandleFunc("/snippet/create", app.createSnippet)
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Handle("/static/", http.StripPrefix("/static", fileServer))
        
        // Передать servemux как «следующий» параметр промежуточному программному обеспечению secureHeaders.
        // Поскольку secureHeaders — это просто функция, и функция возвращает
        // http.Handler, нам больше ничего делать не нужно.
        return secureHeaders(mux)
    }</code></pre>
<p>Давай, попробуй. Запустите приложение, затем откройте второе окно терминала и
    поэкспериментируйте с выполнением некоторых запросов с помощью curl. Вы должны увидеть, что два заголовка безопасности
    теперь включены в каждый ответ.</p>
<pre><code class="terminal">$ curl -I http://localhost:4000/
    HTTP/1.1 200 OK
    X-Frame-Options: deny
    X-Xss-Protection: 1; mode=block
    Date: Wed, 19 Sep 2018 15:24:04 GMT
    Content-Length: 1028
    Content-Type: text/html; charset=utf-8</code></pre>

<h3>Дополнительная информация</h3>
<h4>Поток управления</h4>
<p>Важно знать, что когда последний обработчик в цепочке возвращается, управление передается
    вверх по цепочке в обратном направлении. Итак, когда наш код выполняется, поток
    управления на самом деле выглядит так:</p>
<pre><code>secureHeaders → servemux → application handler → servemux → secureHeaders</code></pre>
<p>В любом обработчике промежуточного слоя код, предшествующий next.ServeHTTP(), будет выполняться
    на пути вниз по цепочке, а любой код после next.ServeHTTP() — или в отложенной
    функции — будет выполняться на обратном пути.</p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Любой код здесь будет выполняться на пути вниз по цепочке.
        next.ServeHTTP(w, r)
        // Любой код здесь будет выполняться на обратном пути вверх по цепочке.
        })
    }</code></pre>
<h4>Ранние возвраты</h4>
<p>Еще одна вещь, о которой следует упомянуть, это то, что если вы вызовете return в своей промежуточной функции перед вызовом
    next.ServeHTTP(), тогда цепочка перестанет выполняться, и управление вернется обратно
    вверх по течению.</p>
<p>Например, распространенным вариантом использования для раннего возврата является промежуточное программное обеспечение аутентификации, которое
    позволяет продолжить выполнение цепочки только в том случае, если определенная проверка пройдена. Например:
    </p>
<pre><code>func myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Если пользователь не авторизован, отправьте статус 403 Forbidden и
        // вернитесь, чтобы остановить выполнение цепочки.
        if !isAuthorized(r) {
            w.WriteHeader(http.StatusForbidden)
            return
        }
        // В противном случае вызовите следующий обработчик в цепочке.
        next.ServeHTTP(w, r)
        })
}</code></pre>
<p>Мы будем использовать этот шаблон «раннего возврата» позже в книге для ограничения доступа к определенным частям
    нашего приложения.</p>

<h2>Глава 6.3. Ведение журнала запросов</h2>
<p>Давайте продолжим в том же духе и добавим промежуточное ПО для регистрации HTTP-запросов.
    В частности, мы собираемся использовать регистратор информации, который мы создали ранее, для записи
    IP-адреса пользователя, а также запрашиваемого URL-адреса и метода.
    Откройте файл middleware.go и создайте метод logRequest(), используя стандартный
    шаблон промежуточного ПО, например:</p>
<pre><code>File: cmd/web/middleware.go

    package main
    ...

    func (app *application) logRequest(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        app.infoLog.Printf("%s - %s %s %s", r.RemoteAddr, r.Proto, r.Method, r.URL.RequestURI())
        next.ServeHTTP(w, r)
        })
    }</code></pre>
<p>Заметили, что на этот раз мы реализуем промежуточное ПО как метод приложения?
</p>
<p>Это вполне допустимо. Наш промежуточный метод имеет ту же сигнатуру, что и раньше, но,
    поскольку это метод, направленный против приложения, он также имеет доступ к зависимостям обработчика,
    включая регистратор информации.</p>
<p>Теперь давайте обновим наш файл route.go, чтобы мидлвар logRequest выполнялся первым
    и для всех запросов, чтобы поток управления (чтение слева направо) выглядел так:
    </p>
<pre><code>logRequest ↔ secureHeaders ↔ servemux ↔ application handler</code></pre>
<hr/>
<pre><code>File: cmd/web/routes.go

    package main
    
    import "net/http"
    
    func (app *application) routes() http.Handler {
        mux := http.NewServeMux()
        mux.HandleFunc("/", app.home)
        mux.HandleFunc("/snippet", app.showSnippet)
        mux.HandleFunc("/snippet/create", app.createSnippet)
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Handle("/static/", http.StripPrefix("/static", fileServer))
        
        // Обернуть существующую цепочку промежуточным программным обеспечением logRequest.
        return app.logRequest(secureHeaders(mux))
    }</code></pre>

<p>Хорошо… давайте попробуем!
    Перезапустите приложение, просмотрите его, а затем проверьте окно терминала. Вы должны
    увидеть вывод журнала, который выглядит примерно так:</p>
<pre><code class="terminal">$ go run ./cmd/web
    INFO 2018/09/19 20:04:54 Starting server on :4000
    INFO 2018/09/19 20:05:49 [::1]:43564 - HTTP/1.1 GET /snippet?id=2
    INFO 2018/09/19 20:05:49 [::1]:43564 - HTTP/1.1 GET /static/css/main.css
    INFO 2018/09/19 20:05:49 [::1]:43566 - HTTP/1.1 GET /static/js/main.js
    INFO 2018/09/19 20:05:50 [::1]:43566 - HTTP/1.1 GET /static/img/logo.png
    INFO 2018/09/19 20:05:50 [::1]:43566 - HTTP/1.1 GET /static/img/favicon.ico
    INFO 2018/09/19 20:05:55 [::1]:43566 - HTTP/1.1 GET /</code></pre>

<p class="note">Примечание. В зависимости от того, как ваш браузер кэширует статические файлы, вам может потребоваться выполнить аппаратное
    обновление (или открыть новую вкладку инкогнито/приватного просмотра), чтобы увидеть любые запросы на статические
    файлы.</p>    

<h2>Глава 6.4. Восстановление при панике</h2>
<p>В простом приложении Go, когда ваш код вызывает панику, это приводит к
    немедленному завершению работы приложения.</p>
<p>Но наше веб-приложение немного сложнее. HTTP-сервер Go предполагает, что
    эффект любой паники изолирован горутиной, обслуживающей активный HTTP-запрос (помните, что
    каждый запрос обрабатывается в своей собственной горутине).</p>
<p>В частности, после паники наш сервер записывает трассировку стека в журнал ошибок сервера, раскручивает
    стек для затронутой горутины (вызывая любые отложенные функции по пути) и закрывает
    базовое HTTP-соединение. Но это не остановит приложение, поэтому важно, что
    любая паника в ваших обработчиках не приведет к остановке вашего сервера.
    </p>
<p>Но если в одном из наших обработчиков случится паника, что увидит пользователь?
    Давайте взглянем и введем преднамеренную панику в наш домашний обработчик.
    </p>
<pre><code>File: cmd/web/handlers.go

    package main
    ...

    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            app.notFound(w)
            return
        }
        panic("oops! something went wrong") // Умышленная паника
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        app.render(w, r, "home.page.tmpl", &templateData{
            Snippets: s,
        })
    }
    ...</code></pre>
<p>Перезапустите приложение…</p>
<pre><code class="terminal">$ go run ./cmd/web
    INFO 2018/09/20 13:18:41 Starting server on :4000</code></pre>
<p>… и сделайте HTTP-запрос домашней страницы из второго окна терминала:</p>
<pre><code class="terminal">$ curl -i http://localhost:4000
    curl: (52) Empty reply from server</code></pre>
<p>К сожалению, все, что мы получаем, — это пустой ответ из-за того, что Go закрывает базовое HTTP-
    соединение после паники.</p>
<p>Это не лучший опыт для пользователя. Вместо этого было бы более уместно и целесообразно
    отправить им правильный HTTP-ответ со статусом 500 Internal Server Error.
    </p>
<p>Аккуратный способ сделать это — создать промежуточное программное обеспечение, которое восстанавливает панику и вызывает
    наш вспомогательный метод app.serverError(). Для этого мы можем использовать тот факт, что отложенные
    функции всегда вызываются, когда стек раскручивается после паники.</p>
<p>Откройте файл middleware.go и добавьте следующий код:</p>

<pre><code>File: cmd/web/middleware.go

    package main

    import (
        "fmt" // New import
        "net/http"
    )
    ...

    func (app *application) recoverPanic(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Создаем отложенную функцию (которая всегда будет запускаться
            // в случае паники, когда Go раскручивает стек).
            defer func() {
                // Используйте встроенную функцию восстановления, чтобы проверить
                // была ли паника или нет. Если есть...
                if err := recover(); err != nil {
                    // Устанавливаем заголовок «Соединение: закрыть» в ответе.
                    w.Header().Set("Connection", "close")
                    // Вызвать вспомогательный метод app.serverError, чтобы вернуть
                    // ответ 500 внутреннего сервера.
                    app.serverError(w, fmt.Errorf("%s", err))
                }
            }()
            next.ServeHTTP(w, r)
        })
    }</code></pre>
<p>Есть две детали по этому поводу, которые стоит объяснить:</p>
<ul>
    <li>Установка соединения: заголовок Close в ответе действует как триггер, заставляющий
        HTTP-сервер Go автоматически закрывать текущее соединение после отправки ответа.
        Он также информирует пользователя о том, что соединение будет закрыто. Примечание. Если используется протокол
        HTTP/2, Go автоматически удалит заголовок Connection: Close из
        ответа (чтобы он не был искажен) и отправит кадр GOAWAY.</li>
    <li>Значение, возвращаемое встроенной функцией recovery(), имеет тип interface{}, и его
        базовый тип может быть строкой, ошибкой или чем-то еще — каким бы ни был параметр,
        переданный в panic(). В нашем случае это строка «упс! что-то пошло не так». в
        код выше, мы нормализуем это как ошибку, используя функцию fmt.Errorf() для
        создания нового объекта ошибки, содержащего текстовое представление
        значения interface{} по умолчанию, а затем передаем эту ошибку вспомогательному методу app.serverError() .
        </li>
</ul>
<p>Давайте теперь применим это в файле route.go, чтобы он выполнялся первым в нашей цепочке
    (чтобы он покрывал паники во всех последующих промежуточных слоях и обработчиках).
</p>
<pre><code>File: cmd/web/routes.go

    package main
    
    import "net/http"
    
    func (app *application) routes() http.Handler {
        mux := http.NewServeMux()
        mux.HandleFunc("/", app.home)
        mux.HandleFunc("/snippet", app.showSnippet)
        mux.HandleFunc("/snippet/create", app.createSnippet)
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Handle("/static/", http.StripPrefix("/static", fileServer))

        // Обернуть существующую цепочку промежуточным программным обеспечением recoveryPanic.
        return app.recoverPanic(app.logRequest(secureHeaders(mux)))
    }</code></pre>

<p>Если вы перезапустите приложение и сделаете запрос на домашнюю страницу сейчас, вы должны увидеть
    хорошо сформированный ответ 500 Internal Server Error после паники, включая
    заголовок Connection: close, о котором мы говорили.</p>

<pre><code class="terminal">$ go run ./cmd/web
    INFO 2018/09/20 16:07:49 Starting server on :4000</code></pre>
<hr/>
<pre><code class="terminal">$ curl -i http://localhost:4000
    HTTP/1.1 500 Internal Server Error
    Connection: close
    Content-Type: text/plain; charset=utf-8
    X-Content-Type-Options: nosniff
    X-Frame-Options: deny
    X-Xss-Protection: 1; mode=block
    Date: Thu, 20 Sep 2018 14:08:25 GMT
    Content-Length: 22
    Internal Server Error</code></pre>
<p>Прежде чем мы продолжим, вернитесь к своему домашнему обработчику и удалите преднамеренную панику из
    кода.</p>
<pre><code>File: cmd/web/handlers.go

    package main
    ...

    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        app.render(w, r, "home.page.tmpl", &templateData{
            Snippets: s,
        })
    }
    ...</code></pre>

<h3>Дополнительная информация</h3>
<h4>Восстановление при панике в других фоновых горутинах</h4>
<p>Важно понимать, что наше промежуточное ПО будет восстанавливать только те паники, которые происходят в той
    же горутине, которая выполнила промежуточное ПО recoveryPanic().</p>
<p>Если, например, у вас есть обработчик, который запускает другую горутину (например, для
    фоновой обработки), то любые паники, которые происходят во второй горутине, не будут
    восстановлены — ни промежуточным программным обеспечением recoveryPanic()…, ни паникой. восстановление встроено
    в сервер Go HTTP. Они заставят ваше приложение завершить работу и вывести сервер из строя.
</p>
<p>Таким образом, если вы запускаете дополнительные горутины из своего веб-приложения и есть
    вероятность паники, вы должны убедиться, что вы восстанавливаете любые паники внутри этих программ.
    слишком. Например:
</p>
<pre><code>func myHandler(w http.ResponseWriter, r *http.Request) {
    ...

    // Запускаем новую горутину для фоновой обработки.
    go func() {
        defer func() {
            if err := recover(); err != nil {
                log.Println(fmt.Errorf("%s\n%s", err, debug.Stack()))
            }
        }()
        doSomeBackgroundProcessing()
    }()
    w.Write([]byte("OK"))

}</code></pre>

<h2>Глава 6.5. Компонуемые цепочки промежуточного программного обеспечения</h2>
<p>В этой главе я хотел бы представить пакет justinas/alice, который поможет нам управлять
    цепочками промежуточного программного обеспечения/обработчика.</p>
<p>Вам не нужно использовать этот пакет, но причина, по которой я рекомендую его, заключается в том, что он упрощает
    создание компонуемых, повторно используемых цепочек промежуточного программного обеспечения — и это может быть реальной помощью по мере
    роста вашего приложения и усложнения ваших маршрутов. Сам пакет также
    небольшой и легкий, а код понятен и хорошо написан.</p>
<p>Чтобы продемонстрировать свои возможности на одном примере, он позволяет вам переписать цепочку обработчиков следующим образом:
</p>
<pre><code>return myMiddleware1(myMiddleware2(myMiddleware3(myHandler)))</code></pre>
<p>В это, что немного яснее понять с первого взгляда:</p>
<pre><code>return alice.New(myMiddleware1, myMiddleware2, myMiddleware3).Then(myHandler)</code></pre>
<p>Но реальная сила заключается в том, что вы можете использовать его для создания цепочек промежуточного программного обеспечения, которые можно
    назначать переменным, добавлять к ним и использовать повторно. Например:</p>
<pre><code>myChain := alice.New(myMiddlewareOne, myMiddlewareTwo)
    myOtherChain := myChain.Append(myMiddleware3)
    return myOtherChain.Then(myHandler)</code></pre>
<p>Давайте обновим наш файл route.go, чтобы использовать пакет justinas/alice следующим образом:</p>
<pre><code>package main

    import (
        "net/http"
        "github.com/justinas/alice" // New import
    )

    func (app *application) routes() http.Handler {
        // Создайте цепочку промежуточного ПО, содержащую наше «стандартное» ПО промежуточного слоя,
        // которое будет использоваться для каждого запроса, получаемого нашим приложением.
        standardMiddleware := alice.New(app.recoverPanic, app.logRequest, secureHeaders)
        
        mux := http.NewServeMux()
        mux.HandleFunc("/", app.home)
        mux.HandleFunc("/snippet", app.showSnippet)
        mux.HandleFunc("/snippet/create", app.createSnippet)
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Handle("/static/", http.StripPrefix("/static", fileServer))
        
        // Возвращаем «стандартную» цепочку промежуточного программного обеспечения, за которой
        // следует servermux.
        return standardMiddleware.Then(mux)
    }</code></pre>
<p>Сохраните файл, затем запустите приложение…</p>
<pre><code class="terminal">$ go run ./cmd/web
    go: downloading github.com/justinas/alice v1.2.0
    INFO 2018/09/20 16:43:49 Starting server on :4000</code></pre>
<p>Поскольку для нашего проекта включены модули, Go достаточно умен, чтобы распознать, что
    наш код импортирует новый сторонний пакет, и автоматически загрузил
    для нас justinas/alice.</p>
<p>Если вы откроете файл go.mod для своего проекта, вы увидите новый оператор require, относящийся к
    этому пакету:</p>
<pre><code>File: go.mod

    module turamant.net/snippetbox
    
    go 1.15
    
    require (
        github.com/go-sql-driver/mysql v1.5.0
        github.com/justinas/alice v1.2.0
    )</code></pre>
<p>Важно отметить, что когда вы полагаетесь на «автоматический» метод загрузки пакетов
    — как мы сделали здесь — Go всегда будет получать последнюю версию пакета. Если вам
    нужна другая конкретная версия, вы должны использовать команду go get вручную, как мы делали ранее.</p>














<p>Конец главы 6.</p>
</body>
</html>