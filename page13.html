<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 13</title>
</head>
<body>
<h1>Глава 13. Тестирование</h1>
<p>И вот мы наконец подошли к теме тестирования. Как и в случае структурирования и организации кода вашего приложения, в Go
    не существует единственного «правильного» способа структурировать и организовать ваши тесты.
    Но есть некоторые условности, шаблоны и
    передовой опыт, которым вы можете следовать.</p>
<p>В этот раздел мы собирались добавить тесты для выбора кода в нашем приложении с
    целью продемонстрировать общий синтаксис создания тестов и проиллюстрировать некоторые
    шаблоны, которые можно повторно использовать в самых разных приложениях.
    Вы узнаете:</p>
    <ul>
        <li>Как создавать и запускать модульные тесты и подтесты на основе таблиц в Go.</li>
        <li>Как провести модульное тестирование ваших обработчиков HTTP и промежуточного программного обеспечения.</li>
        <li>Как выполнить «сквозное» тестирование маршрутов, промежуточного программного обеспечения и
            обработчиков вашего веб-приложения.</li>
        <li>Как создавать макеты моделей вашей базы данных и использовать их в модульных тестах.</li>
        <li>Шаблон для тестирования отправки HTML-форм, защищенных CSRF.</li>
        <li>Как использовать тестовый экземпляр MySQL для выполнения интеграционных тестов.</li>
        <li>Kак использовать тестовый экземпляр MySQL для выполнения интеграционных тестов.</li>
    </ul>

<h2>13.1 Модульное тестирование и подтесты</h2>
<p>В этой главе мы создадим модульный тест, чтобы убедиться, что наша функция humanDate() (которую мы
    создали еще в главе «Функции пользовательского шаблона») выводит значения time.Time
    именно в том формате, который нам нужен.</p>
<p>Если вы не помните, функция humanDate() выглядит так:</p>
<pre><code>
File: cmd/web/templates.go

package main
...

func humanDate(t time.Time) string {
    return t.UTC().Format("02 Jan 2006 at 15:04")
}

...
</code></pre>

<p>Причина, по которой я хочу начать с тестирования, заключается в том, что это простая функция. Мы можем
    изучить базовый синтаксис и шаблоны написания тестов, не слишком увлекаясь
    тестируемой функциональностью.</p>

<h3>Cоздание модульного теста</h3>
<p>Давайте сразу приступим к созданию модульного теста для этой функции.
    В Go стандартной практикой является создание тестов в файлах *_test.go, которые размещаются непосредственно
    рядом с кодом, который вы тестируете. Итак, в этом случае первое, что мы собираемся сделать, это
    создать новый файл cmd/web/templates_test.go для хранения теста:</p>
<p class="terminal">
    $ touch cmd/web/templates_test.go
</p>

<p>И затем мы можем создать новый модульный тест для функции humanDate следующим образом:</p>
<pre><code>
File: cmd/web/templates_test.go

package main

import (
    "testing"
    "time"
)

func TestHumanDate(t *testing.T) {
    // Инициализируйте новый объект time.Time и передайте его функции humanDate.
    tm := time.Date(2020, 12, 17, 10, 0, 0, 0, time.UTC)
    hd := humanDate(tm)

    // Убедитесь, что выходные данные функции humanDate находятся в ожидаемом 
    // формате. Если это не то, что мы ожидаем, используйте функцию t.Errorf(), чтобы
    // указать, что тест не пройден, и записать ожидаемые и фактические
    // значения.
    if hd != "17 Dec 2020 at 10:00" {
        t.Errorf("want %q; got %q", "17 Dec 2020 at 10:00", hd)
    }
}
</code></pre>
<p>Этот шаблон является основным, который вы будете использовать практически для всех тестов, написанных на Go. Важные
    вещи, которые следует вынести:</p>
    <ul>
        <li>тест — это обычный код Go, который вызывает функцию humanDate и проверяет,
            соответствует ли результат ожидаемому.</li>
        <li>Ваши модульные тесты содержатся в обычной функции Go с сигнатурой
            func(*testing.T).</li>
        <li>Чтобы быть действительным модульным тестом, имя этой функции должно начинаться со слова Test. Обычно
            за этим следует имя тестируемой функции, метода или типа, чтобы
            с первого взгляда было понятно, что тестируется.</li>
        <li> Вы можете использовать функцию t.Errorf(), чтобы пометить тест как неудавшийся и записать описательное
            сообщение об ошибке.</li>
    </ul>
    <p>Давайте попробуем это. Сохраните файл, затем используйте команду go test, чтобы запустить все тесты в нашем
        пакете cmd/web следующим образом:</p>
    <p class="terminal">
        $ go test ./cmd/web
        ok turamant.net/snippetbox/cmd/web 0.005s</p>
<p>Итак, это хорошая вещь. Знак ok в этом выводе означает, что все тесты в пакете (на данный момент
    только наш тест TestHumanDate()) прошли без проблем.</p>
<p>Если вам нужна более подробная информация, вы можете увидеть, какие именно тесты выполняются, используя флаг -v для
    получения подробного вывода:</p>
<p class="terminal">
    $ go test -v ./cmd/web
    
    === RUN TestHumanDate
    --- PASS: TestHumanDate (0.00s)
    PASS
    
    ok turamant.net/snippetbox/cmd/web 0.007s
</p> 
    

<h3>Table-Driven Tests..........................................</h3>

</body>
</html>
   
    