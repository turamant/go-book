<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 5</title>
</head>
<body>
    <nav>
        <ul>
            <li><a href="page1.html">page1</a></li>
            <li><a href="page2.html">page2</a></li>
            <li><a href="page3.html">page3</a></li>
            <li><a href="page4.html">page4</a></li>
            <li><a href="page5.html">page5</a></li>
            <li><a href="page6.html">page6</a></li>
            <li><a href="page7.html">page7</a></li>
            <li><a href="page8.html">page8</a></li>
            <li><a href="page9.html">page9</a></li>
            <li><a href="page10.html">page10</a></li>
        </ul>
    </nav>
<h1>Глава 5. Динамические HTML-шаблоны</h1>
<p>В этом разделе книги мы сосредоточимся на отображении динамических данных из
    нашей базы данных MySQL на некоторых соответствующих HTML-страницах.
    </p>
<p>Вы узнаете, как:</p>
<ul>
    <li>Передавать динамические данные в HTML-шаблоны простым, масштабируемым и типобезопасным способом.
    </li>
    <li>Используйте различные действия и функции в пакете html/template Go для управления отображением
        динамических данных.</li>
    <li>Создайте кеш шаблонов, чтобы ваши шаблоны не считывались с диска при каждом
        HTTP-запросе.</li>
    <li>Изящно обрабатывайте ошибки рендеринга шаблонов во время выполнения.
    </li>
    <li>Реализуйте шаблон для передачи общих динамических данных на ваши веб-страницы без
        повторения кода.</li>
    <li>Создавайте собственные пользовательские функции для форматирования и отображения данных в шаблонах HTML.
    </li>
</ul>

<h2>Глава 5.1. Отображение динамических данных</h2>
<p>В настоящее время наша функция-обработчик showSnippet извлекает объект models.Snippet из
    базы данных, а затем выводит содержимое в текстовом HTTP-ответе.
    </p>
<p>В этом разделе мы обновим это, чтобы данные отображались на правильной веб-странице HTML
    , которая выглядит примерно так:</p>
<p><img src="static/images/picture5.1.png"/></p>
<p>Начнем с обработчика showSnippet и добавим код для рендеринга нового
    файла шаблона show.page.tmpl (который мы создадим через минуту). Надеюсь, это должно показаться вам знакомым
    из 
    
<pre><code>File: cmd/web/handlers.go

    package main
    
    import (
        "errors"
        "fmt"
        "html/template" // Uncomment import
        "net/http"
        "strconv"
        "turamant.net/snippetbox/pkg/models"
    )
    ...

    func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
        id, err := strconv.Atoi(r.URL.Query().Get("id"))
        if err != nil || id < 1 {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Get(id)
        if err != nil {
            if errors.Is(err, models.ErrNoRecord) {
                app.notFound(w)
            } else {
                app.serverError(w, err)
            }
        return
        }
        // Инициализируем слайс, содержащий пути к файлу show.page.tmpl,
        // а также базовый макет и партиал нижнего колонтитула, которые мы сделали ранее. 
        files := []string{
        "./ui/html/show.page.tmpl",
        "./ui/html/base.layout.tmpl",
        "./ui/html/footer.partial.tmpl",
        }

        // Разбираем файлы шаблона...
        ts, err := template.ParseFiles(files...)

        if err != nil {
            app.serverError(w, err)
            return
        }
        // И затем выполнить их. Обратите внимание, как мы передаем сниппет
        // данные (структура models.Snippet) в качестве последнего параметра.
        err = ts.Execute(w, s)
        
        if err != nil {
            app.serverError(w, err)
        }
    }
    ...</code></pre>

<p>Далее нам нужно создать файл show.page.tmpl, содержащий разметку HTML для страницы
    . Но прежде чем мы это сделаем, мне нужно объяснить небольшую теорию…
    </p>
<p>В ваших HTML-шаблонах любые динамические данные, которые вы передаете, представлены расширением .
    символ (называемый точкой).</p>
<p>В этом конкретном случае базовым типом точки будет структура models.Snippet. Когда
    базовым типом точки является структура, вы можете отображать (или выдавать) значение любого экспортируемого поля,
    добавляя после точки точку с именем поля. Итак, поскольку наша структура models.Snippet имеет поле Title,
    мы можем получить заголовок фрагмента, написав {{.Title}} в наших шаблонах.
    </p>
<p>Я продемонстрирую. Создайте новый файл по адресу ui/html/show.page.tmpl и добавьте следующую
    разметку:
    </p>
<pre><code>File: ui/html/show.page.tmpl

    {{template "base" .}}
    
    {{define "title"}}Snippet #{{.ID}}{{end}}
    
    {{define "main"}}
    &lt;div class='snippet'&gt;
        &lt;div class='metadata'&gt;
            &lt;strong&gt;{{.Title}}&lt;/strong&gt;
            &lt;span&gt;#{{.ID}}&lt;/span&gt;
        &lt;/div&gt;
        &lt;pre&gt;&lt;code&gt;{{.Content}}&lt;/code&gt;&lt;/pre&gt;
        &lt;div class='metadata'&gt;
            &lt;time&gt;Created: {{.Created}}&lt;/time&gt;
            &lt;time&gt;Expires: {{.Expires}}&lt;/time&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    {{end}}</code></pre>

<p>Если вы перезапустите приложение и посетите http://localhost:4000/snippet?id=1 в своем
    браузере, вы обнаружите, что соответствующий фрагмент извлекается из базы данных, передается в
    шаблон, и содержимое отображается правильно.</p>
<p><img src="static/images/picture5.2.png"/></p>


<h3>Рендеринг нескольких фрагментов данных</h3>
<p>Важно объяснить, что пакет html/template в Go позволяет передавать один
    — и только один — элемент динамических данных при рендеринге шаблона. Но в реальном
    приложении часто есть несколько фрагментов динамических данных, которые вы хотите отобразить на
    одной странице.</p>
<p>Важно объяснить, что пакет html/template в Go позволяет передавать один
    — и только один — элемент динамических данных при рендеринге шаблона. Но в реальном
    приложении часто есть несколько фрагментов динамических данных, которые вы хотите отобразить на
    одной странице.</p>
<p>Давайте создадим новый файл cmd/web/templates.go, содержащий структуру templateData, которая сделает
    именно это.</p>


<pre><code class="terminal">$ touch cmd/web/templates.go</code></pre>
<pre><code>File: cmd/web/templates.go

    package main

    import "turamant.net/snippetbox/pkg/models"
    // Определяем тип templateData, который будет выступать в качестве удерживающей структуры для
    // любых динамических данных, которые мы хотим передать в наши HTML-шаблоны.
    // На данный момент он содержит только одно поле, но мы добавим
    // в него больше по ходу сборки.
    type templateData struct {
        Snippet *models.Snippet
    }</code></pre>

    <p>А затем давайте обновим обработчик showSnippet, чтобы использовать эту новую структуру при выполнении наших
        шаблонов.</p>

<pre><code>File: cmd/web/handlers.go

    package main
    ...

    func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
        id, err := strconv.Atoi(r.URL.Query().Get("id"))
        if err != nil || id < 1 {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Get(id)
        if err != nil {
            if errors.Is(err, models.ErrNoRecord) {
                app.notFound(w)
            } else {
                app.serverError(w, err)
            }
        return
        }

        // Создаем экземпляр структуры templateData, содержащей данные сниппета.
        data := &templateData{Snippet: s}
        files := []string{
            "./ui/html/show.page.tmpl",
            "./ui/html/base.layout.tmpl",
            "./ui/html/footer.partial.tmpl",
        }
        ts, err := template.ParseFiles(files...)
        if err != nil {
            app.serverError(w, err)
            return
        }
        // Передаем структуру templateData при выполнении шаблона.
        err = ts.Execute(w, data)
        if err != nil {
            app.serverError(w, err)
        }
    }
    ...</code></pre>
<p>Итак, теперь данные нашего фрагмента содержатся в структуре models.Snippet внутри
    структуры templateData. Чтобы получить данные, нам нужно соединить соответствующие имена полей вместе следующим образом:</p>

<pre><code>File: ui/html/show.page.tmpl

    {{template "base" .}}

    {{define "title"}}Snippet #{{.Snippet.ID}}{{end}}

    {{define "main"}}
    &lt;div class='snippet'&gt;
        &lt;div class='metadata'&gt;
            &lt;strong&gt;{{.Snippet.Title}}&lt;/strong&gt;
            &lt;span&gt;#{{.Snippet.ID}}&lt;/span&gt;
        &lt;/div&gt;
        &lt;pre&gt;&lt;code&gt;{{.Snippet.Content}}&lt;/code&gt;&lt;/pre&gt;
        &lt;div class='metadata'&gt;
            &lt;time&gt;Created: {{.Snippet.Created}}&lt;/time&gt;
            &lt;time&gt;Expires: {{.Snippet.Expires}}&lt;/time&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    {{end}}</code></pre>

<p>Не стесняйтесь перезапустить приложение и снова посетить http://localhost:4000/snippet?id=1.
    Вы должны увидеть ту же страницу, отображаемую в вашем браузере, что и раньше.</p>

<h3>Дополнительная информация</h3>
<h4>Экранирование</h4>
<p>Пакет html/template автоматически экранирует любые данные, заключенные между
    тегами {{ }}. Такое поведение очень полезно для предотвращения атак межсайтового скриптинга (XSS) и является причиной
    того, что вам следует использовать пакет html/template вместо более общего
    пакета text/template, который также предоставляет Go.
    </p>
<p>В качестве примера экранирования, если динамические данные, которые вы хотели получить, были:
</p>
<pre><code>&lt;span&gt;{{"&lt;script&gt;alert('xss attack')&lt;/script&gt;"}}&lt;/span&gt;</code></pre>

<p>Это будет безобидно представлено как:</p>
<pre><code>lt;span&gt;&lt;script&gt;alert(&#39;xss attack&#39;)&lt;/script&gt;&lt;/span&gt;&</code></pre>
<p>Пакет html/template также достаточно умен, чтобы сделать экранирование зависимым от контекста. Он
    будет использовать соответствующие escape-последовательности в зависимости от того, отображаются ли данные в той
    части страницы, которая содержит HTML, CSS, Javascript или URI.</p>

<h3>Вложенные шаблоны</h3>
<p>Очень важно отметить, что когда вы вызываете один шаблон из другого
    шаблона, точка должна быть явно передана или конвейеризирована в вызываемый шаблон. Вы
    делаете это, добавляя его в конце каждого действия {{template}} или {{block}}, например:</p>
<pre><code>{{template "base" .}}
    {{template "main" .}}
    {{template "footer" .}}
    {{block "sidebar" .}}{{end}}</code></pre>

<p>Как правило, мой совет состоит в том, чтобы выработать привычку всегда использовать точку при вызове шаблона
    с помощью действий {{template}} или {{block}}, если только у вас нет веских причин этого не делать.</p>

<h4>Вызов методов</h4>
<p>Если объект, который вы возвращаете, имеет методы, определенные для него, вы можете вызывать их (при условии, что
    они экспортируются и возвращают только одно значение — или одно значение и ошибку).
    </p>
<p>Например, если .Snippet.Created имеет базовый тип time.Time (что он и имеет), вы
    можете отобразить название дня недели, вызвав его метод Weekday() следующим образом:
    </p>
<pre><code>&lt;span&gt;{{.Snippet.Created.Weekday}}&lt;/span&gt;</code></pre>
<p>Вы также можете передавать параметры методам. Например, вы можете использовать
    метод AddDate(), чтобы добавить шесть месяцев ко времени следующим образом:</p>
<pre><code>&lt;span&gt;{{.Snippet.Created.AddDate 0 6 0}}&lt;/span&gt;</code></pre>
<p>Обратите внимание, что это другой синтаксис для вызова функций в Go — параметры не
    заключены в круглые скобки и разделены одним пробелом, а не запятой.</p>
<h3>
</h3>
<p>HTML-комментарииНаконец, пакет html/template всегда удаляет любые HTML-комментарии, которые вы включаете в
    свои шаблоны, включая любые условные комментарии.</p>
<p>Это делается для того, чтобы избежать XSS-атак при рендеринге динамического контента. Разрешение
    условных комментариев будет означать, что Go не всегда может предвидеть, как браузер
    будет интерпретировать разметку на странице, и, следовательно, он не обязательно сможет
    правильно экранировать все. Чтобы решить эту проблему, Go просто удаляет все HTML-комментарии.
    </p>

<h2>Глава 5.2. Действия и функции шаблона</h2>
<p>В этом разделе мы рассмотрим действия и функции шаблона, которые предоставляет Go.
    Мы уже говорили о некоторых действиях — {{define}}, {{template}} и
    {{block}} — но есть еще три, которые вы можете использовать для управления отображением динамических
    данных — {{if}} , {{с}} и {{диапазон}}.</p>
<table>
    <tr>
        <th>Действие</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>{{if .Foo}} C1 {{else}} C2 {{end}}</td>
        <td>Если .Foo не пуст, визуализируйте содержимое C1,
            в противном случае визуализируйте содержимое C2.</td>
    </tr>
    <tr>
        <td>{{with .Foo}} C1 {{else}} C2 {{end}}</td>
        <td>Если .Foo не пусто, установите точку в значение
            .Foo и визуализируйте содержимое C1, в противном случае визуализируйте содержимое
            C2.
        </td>
    </tr>
    <tr>
        <td>{{range .Foo}} C1 {{else}} C2 {{end}}</td>
        <td>Если длина .Foo больше нуля, то перебираем
            каждый элемент, устанавливая точку в значение каждого
            элемента и отображая содержимое C1. Если длина
            .Foo равна нулю, визуализируйте содержимое C2. Базовый
            тип .Foo должен быть массивом, срезом, картой
            или каналом.</td>
    </tr>  
</table> 
<p>В этих действиях есть несколько моментов, на которые стоит обратить внимание:</p>
<ul>
    <li>Для всех трех действий предложение {{else}} является необязательным. Например, вы можете написать
        {{if .Foo}} C1 {{end}}, если нет содержимого C2, которое вы хотите отобразить.
        </li>
    <li>Пустыми значениями являются false, 0, любой нулевой указатель или значение интерфейса, а также любой массив, срез, карта
        или строка нулевой длины.</li>
    <li>Важно понимать, что действия with и range изменяют значение точки. Как только
        вы начнете их использовать, то, что представляет точка, может отличаться в зависимости от того, где вы находитесь в
        шаблоне и что вы делаете.</li>
</ul>
<p>Пакет html/template также предоставляет некоторые функции шаблонов, которые вы можете использовать для
    добавления дополнительной логики в свои шаблоны и управления тем, что отображается во время выполнения. Вы можете найти
    полный список функций здесь, но наиболее важными из них являются:</p>
<table>
    <tr>
        <th>Функция</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>{{eq .Foo .Bar}}</td>
        <td>Возвращает true, если .Foo равно .Bar</td>
    </tr>
    <tr>
        <td>{{ne .Foo .Bar}}</td>
        <td>Возвращает true, если .Foo не равно .Bar</td>
    </tr>
    <tr>
        <td>{{not .Foo}}</td>
        <td>Yields the boolean negation of .Foo</td>
    </tr>
    <tr>
        <td>{{or .Foo .Bar}}</td>
        <td>Выдает .Foo, если .Foo не пусто; в противном случае дает .Bar</td>
    </tr>
    <tr>
        <td>{{index .Foo i}}</td>
        <td>Возвращает значение .Foo по индексу i. Базовый тип
            .Foo должен быть картой, срезом или массивом.</td>
    </tr>
    <tr>
        <td>{{printf "%s-%s" .Foo .Bar}}</td>
        <td>Выдает отформатированную строку, содержащую значения .Foo и .Bar
            . Работает так же, как fmt.Sprintf().</td>
    </tr>
    <tr>
        <td>{{len .Foo}}</td>
        <td>Выдает длину .Foo в виде целого числа.</td>
    </tr>
    <tr>
        <td>{{$bar := len .Foo}}</td>
        <td>Назначьте длину .Foo переменной шаблона $bar</td>
    </tr>    
</table> 
<p>Последняя строка является примером объявления переменной шаблона. Переменные шаблона
    особенно полезны, если вы хотите сохранить результат функции и использовать его в нескольких
    местах вашего шаблона. Имена переменных должны начинаться со знака доллара и могут содержать
    только буквенно-цифровые символы.</p>
<h3>Использование действия With</h3>
<p>Хорошей возможностью использовать действие {{with}} является файл show.page.tmpl, который мы создали в
    предыдущей главе. Идите вперед и обновите его следующим образом:</p>
<pre><code>File: ui/html/show.page.tmpl

    {{template "base" .}}
    
    {{define "title"}}Snippet #{{.Snippet.ID}}{{end}}
    
    {{define "main"}}
    
        {{with .Snippet}}
        &lt;div class='snippet'&gt;
            &lt;div class='metadata'&gt;
                &lt;strong&gt;{{.Title}}&lt;/strong&gt;
                &lt;span&gt;#{{.ID}}&lt;/span&gt;
            &lt;/div&gt;
            &lt;pre&gt;&lt;code&gt;{{.Content}}&lt;/code&gt;&lt;/pre&gt;
            &lt;div class='metadata'&gt;
                &lt;time&gt;Created: {{.Created}}&lt;/time&gt;
                &lt;time&gt;Expires: {{.Expires}}&lt;/time&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        {{end}}
    {{end}}</code></pre>

<p>Итак, теперь между {{with .Snippet}} и соответствующим тегом {{end}} значение точки
    установлено в .Snippet. По сути, точка становится структурой models.Snippet вместо родительской
    структуры templateData.</p>
<h3>Использование действий If и Range</h3>
<p>Давайте также воспользуемся действиями {{if}} и ​​{{range}} в конкретном примере и обновим нашу
    домашнюю страницу, чтобы отобразить таблицу с последними фрагментами кода, примерно так:</p>
<p><img src="static/images/picture5.3.png"/></p>
<p>Сначала обновите структуру templateData, чтобы она содержала поле Snippets для хранения части
    фрагментов, например так:</p>
<pre><code>File: cmd/web/templates.go
    
    package main
    
    import "turamant.net/snippetbox/pkg/models"
    
    // Включить поле Snippets в структуру templateData.
    type templateData struct {
        Snippet *models.Snippet
        Snippets []*models.Snippet
    }</code></pre>
<p>Затем обновите функцию домашнего обработчика, чтобы она извлекала последние фрагменты из нашей
    модели базы данных и передавала их в шаблон home.page.tmpl:</p>

<pre><code>File: cmd/web/handlers.go

    package main
    ...
    
    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        // Создать экземпляр структуры templateData, содержащей фрагмент
        // фрагментов.
        data := &templateData{Snippets: s}
        files := []string{
            "./ui/html/home.page.tmpl",
            "./ui/html/base.layout.tmpl",
            "./ui/html/footer.partial.tmpl",
        }
        ts, err := template.ParseFiles(files...)
        if err != nil {
            app.serverError(w, err)
            return
        }
        // Передаем структуру templateData при выполнении шаблона.
        err = ts.Execute(w, data)
        if err != nil {
            app.serverError(w, err)
        }
    }
    ...</code></pre>
<p>Теперь давайте перейдем к файлу ui/html/home.page.tmpl и обновим его для отображения этих
    фрагментов в таблице с помощью действий {{if}} и ​​{{range}}. В частности:
    </p>
<ul>
    <li>Mы хотим использовать действие {{if}}, чтобы проверить, является ли фрагмент фрагментов пустым или нет.
        Если он пуст, мы хотим отобразить сообщение «Здесь пока нечего видеть!».
        В противном случае мы хотим отобразить таблицу, содержащую информацию о фрагменте.
        </li>
    <li>Мы хотим использовать действие {{range}} для перебора всех фрагментов в slice, выводя
        содержимое каждого фрагмента в строку таблицы.</li>
</ul>
<p>Вот разметка:</p>
<pre><code>File: ui/html/home.page.tmpl

    {{template "base" .}}
    
    {{define "title"}}Home{{end}}
    
    {{define "main"}}
        &lt;h2&gt;Latest Snippets&lt;/h2&gt;
        {{if .Snippets}}
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th&gt;Title&lt;/th&gt;
                &lt;th&gt;Created&lt;/th&gt;
                &lt;th&gt;ID&lt;/th&gt;
            &lt;/tr&gt;
            {{range .Snippets}}
            &lt;tr&gt;
                &lt;td&gt;&lt;a href='/snippet?id={{.ID}}'&gt;{{.Title}}&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;{{.Created}}&lt;/td&gt;
                &lt;td&gt;#{{.ID}}&lt;/td&gt;
            &lt;/tr&gt;
            {{end}}
        &lt;/table&gt;
        {{else}}
            &lt;p&gt;There's nothing to see here... yet!&lt;/p&gt;
        {{end}}
    {{end}}</code></pre>
<p>Убедитесь, что все ваши файлы сохранены, перезапустите приложение и посетите http://localhost:4000
    в веб-браузере. Если все идет по плану, вы должны увидеть страницу, которая выглядит примерно
    так:</p>
<p><img src="static/images/picture5.4.png"/></p>

<h2>Глава 5.3. Кэширование шаблонов</h2>
<p>Прежде чем мы добавим в наши HTML-шаблоны какую-либо дополнительную функциональность, самое время
    немного оптимизировать нашу кодовую базу. На данный момент есть две основные проблемы:
    </p>
<ol>
    <li>Каждый раз, когда мы отображаем веб-страницу, наше приложение считывает и анализирует
        соответствующие файлы шаблонов с помощью функции template.ParseFiles(). Мы могли бы избежать этой
        дублирующей работы, проанализировав файлы один раз — при запуске приложения — и сохранив
        проанализированные шаблоны в кеше в памяти.</li>
    <li>В обработчиках home и showSnippet дублируется код, и мы могли бы уменьшить
        это дублирование, создав вспомогательную функцию.</li>
</ol>
<p>
Давайте сначала займемся первой точкой и создадим карту в памяти с типом
map[string]*template.Template для кэширования проанализированных шаблонов. Откройте
файл cmd/web/templates.go и добавьте следующий код:</p>

<pre><code>File: cmd/web/templates.go

    package main
    
    import (
        "html/template" // New import
        "path/filepath" // New import
        "turamant.net/snippetbox/pkg/models"
    )
    ...

    func newTemplateCache(dir string) (map[string]*template.Template, error) {
        // Инициализировать новую карту, чтобы она действовала как кеш.
        cache := map[string]*template.Template{}
        
        // Используйте функцию filepath.Glob, чтобы получить часть всех путей к файлам
        // с расширением '.page.tmpl'. По сути, это дает нам часть всех
        // шаблонов 'страниц' для приложения.
        pages, err := filepath.Glob(filepath.Join(dir, "*.page.tmpl"))
        
        if err != nil {
            return nil, err
        }

        // Перебираем страницы одну за другой.
        for _, page := range pages {
            // Извлечь имя файла (например, 'home.page.tmpl') из полного пути к файлу
            // и присвоить его переменной name.
            name := filepath.Base(page)
            
            // Разбираем файл шаблона страницы в набор шаблонов.
            ts, err := template.ParseFiles(page)
            if err != nil {
                return nil, err
            }

            // Используйте метод ParseGlob для добавления любых шаблонов макета в
            // набор шаблонов (в нашем случае это просто базовый макет
            // на данный момент).
            ts, err = ts.ParseGlob(filepath.Join(dir, "*.layout.tmpl"))
            
            if err != nil {
                return nil, err
            }

            // Используйте метод ParseGlob, чтобы добавить любые 'частичные' шаблоны в
            // набор шаблонов (в нашем случае это только 'нижний колонтитул'
            // на данный момент).
            ts, err = ts.ParseGlob(filepath.Join(dir, "*.partial.tmpl"))
            
            if err != nil {
                return nil, err
            }

            // Добавляем набор шаблонов в кеш, используя имя страницы
            // (например, 'home.page.tmpl') в качестве ключа.
            cache[name] = ts
            }

        // Вернуть карту.
        return cache, nil
    }</code></pre>

<p>Следующий шаг — инициализировать этот кеш в функции main() и сделать его доступным для наших
    обработчиков в качестве зависимости через структуру приложения, например:</p>

<pre><code>File: cmd/web/main.go

    package main
    
    import (
        "database/sql"
        "flag"
        "html/template" // Новый импорт
        "log"
        "net/http"
        "os"
        "turamant.net/snippetbox/pkg/models/mysql"
        _ "github.com/go-sql-driver/mysql"
    )
    ...
    // Добавляем поле templateCache в структуру приложения.
    type application struct {
        errorLog *log.Logger
        infoLog *log.Logger
        snippets *mysql.SnippetModel
        templateCache map[string]*template.Template
    }

    func main() {
        dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "MySQL data source name")
        addr := flag.String("addr", ":4000", "HTTP network address")
        flag.Parse()
        infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
        errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
        db, err := openDB(*dsn)

        if err != nil {
            errorLog.Fatal(err)
        }

        defer db.Close()

        // Инициализировать новый кэш шаблонов...
        templateCache, err := newTemplateCache("./ui/html/")
        
        if err != nil {
            errorLog.Fatal(err)
        }

        // И добавляем его в зависимости приложения.
        app := &application{
            errorLog: errorLog,
            infoLog: infoLog,
            snippets: &mysql.SnippetModel{DB: db},
            templateCache: templateCache,
        }
        srv := &http.Server{
            Addr: *addr,
            ErrorLog: errorLog,
            Handler: app.routes(),
        }

        infoLog.Printf("Starting server on %s", *addr)err = srv.ListenAndServe()
        errorLog.Fatal(err)
    }
    ...</code></pre>
<p>Итак, на данный момент у нас есть кеш в памяти соответствующего набора шаблонов для каждой из наших
    страниц, и наши обработчики имеют доступ к этому кешу через структуру приложения.
    </p>
<p>Давайте теперь решим вторую проблему дублирования кода и создадим вспомогательный метод, чтобы
    мы могли легко отображать шаблоны из кеша.</p>
<p>Откройте файл cmd/web/helpers.go и добавьте следующий метод:</p>
<pre><code>Файл: cmd/web/helpers.go

    package main
    ...
    
    func (app *application) render(w http.ResponseWriter, r *http.Request, name string, td *templateData) {
        // Получить соответствующий набор шаблонов из кэша на основе имени страницы
        // (например, 'home.page.tmpl'). Если в кэше нет записи с
        // указанным именем, вызовите вспомогательный метод serverError, который мы сделали ранее.
        ts, ok := app.templateCache[name]

        if !ok {
            app.serverError(w, fmt.Errorf("Шаблон %s не существует", name))
            return
        }

        Выполнить набор шаблонов, передав любые динамические данные.
        err := ts.Execute(w, td)
        
        if err != nil {
            app.serverError(w, err)
        }
    }</code></pre>
<p>На этом этапе вам может быть интересно, почему сигнатура для метода render() включает
    параметр *http.Request… хотя он нигде не используется. Это просто для защиты сигнатуры метода в будущем, потому что позже в книге нам понадобится доступ к ней.
    </p>
<p>Теперь, когда это завершено, мы можем увидеть отдачу от этих изменений и можем значительно
    упростить код в наших обработчиках:</p>

<pre><code>File: cmd/web/handlers.go
    
    package main
    
    import (
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "turamant.net/snippetbox/pkg/models"
    )
    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        // Использовать новый помощник рендеринга.
        app.render(w, r, "home.page.tmpl", &templateData{
            Snippets: s,
        })
    }
    func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
        id, err := strconv.Atoi(r.URL.Query().Get("id"))
        if err != nil || id < 1 {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Get(id)
        if err != nil {
            if errors.Is(err, models.ErrNoRecord) {
                app.notFound(w)
            } else {
                app.serverError(w, err)
            }
        return
        }
        // Использовать новый помощник рендеринга.
        app.render(w, r, "show.page.tmpl", &templateData{
            Snippet: s,
        })
    }
    ...</code></pre>

<h2>Chapter 5.4.
    Catching Runtime Errors</h2>
    ......................
    .........
<p>Конец главы 5.</p>
</body>
</html>