<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 7</title>
</head>
<body>
<h1>Глава 7. RESTful-маршрутизация</h1>
<p>В следующем разделе этой книги мы добавим HTML-форму в наше веб-приложение, чтобы
    пользователи могли создавать новые фрагменты кода.</p>
<p>Чтобы все работало гладко, мы собираемся обновить маршруты наших приложений, чтобы запросы
    к /snippet/create обрабатывались по-разному в зависимости от метода запроса. В частности:
    </p>
<ul>
    <li>Для запросов GET /snippet/create мы хотим показать пользователю HTML-форму для добавления
        нового фрагмента.</li>
    <li>Для запросов POST /snippet/create мы хотим обработать данные этой формы, а затем вставить
        новую запись фрагмента в нашу базу данных.</li>
</ul>
<p>Пока мы на этом, имеет смысл также ограничить другие наши маршруты, которые просто возвращают
    информацию, чтобы поддерживать только запросы GET (и HEAD).
    </p>
<p>По сути, мы хотим, чтобы маршруты наших приложений выглядели так:
</p>

<table>
    <tr>
        <th>Method</th>
        <th>Шаблон</th>
        <th>Handler</th>
        <th>Действие</th>
    </tr>
    <tr>
        <td>GET</td>
        <td>/</td>
        <td>home</td>
        <td>Показать домашнюю страницу</td>
    </tr>
    <tr>
        <td>GET</td>
        <td>/snippet?id=1</td>
        <td>showSnippet</td>
        <td>Показать определенный фрагмент</td>
    </tr>
    <tr>
        <td>GET</td>
        <td>/snippet/create</td>
        <td>createSnippetForm</td>
        <td>Показать новую форму фрагмента</td>
    </tr>
    <tr>
        <td>POST</td>
        <td>/snippet/create</td>
        <td>createSnippet</td>
        <td>Создать новый фрагмент</td>
    </tr>
    <tr>
        <td>Любой</td>
        <td>/static/</td>
        <td>http.FileServer</td>
        <td>Показать определенный статический файл</td>
    </tr>  
</table>
<p>Еще одним улучшением, связанным с маршрутизацией, будет использование семантических URL-адресов, чтобы любые переменные
    включались в путь URL-адреса, а не добавлялись в виде строки запроса, например:</p>

<table>
    <tr>
        <th>Method</th>
        <th>Шаблон</th>
        <th>Handler</th>
        <th>Действие</th>
    </tr>
    <tr>
        <td>GET</td>
        <td>/</td>
        <td>home</td>
        <td>Показать домашнюю страницу</td>
    </tr>
    <tr>
        <td>GET</td>
        <td>/snippet/:id</td>
        <td>showSnippet</td>
        <td>Показать определенный фрагмент</td>
    </tr>
    <tr>
        <td>GET</td>
        <td>/snippet/create</td>
        <td>createSnippetForm</td>
        <td>Показать новую форму фрагмента</td>
    </tr>
    <tr>
        <td>POST</td>
        <td>/snippet/create</td>
        <td>createSnippet</td>
        <td>Создать новый фрагмент</td>
    </tr>
    <tr>
        <td>Любой</td>
        <td>/static/</td>
        <td>http.FileServer</td>
        <td>Показать определенный статический файл</td>
    </tr>  
</table>
<p>Внесение этих изменений дало бы нам структуру маршрутизации приложений, которая следует
    фундаментальным принципам REST и должна казаться знакомой и логичной всем, кто
    работает с современными веб-приложениями.</p>
<p>Но, как я упоминал ранее в книге, servermux Go не поддерживает
    маршрутизацию на основе методов или семантические URL-адреса с переменными в них. Есть несколько приемов, которые вы можете использовать, чтобы обойти
    это, но большинство людей склонны решать, что проще обратиться к стороннему
    пакету, который поможет с маршрутизацией.</p>
<p>В этом разделе книги мы:</p>
<ul>
    <li>Кратко обсудим особенности нескольких хороших сторонних маршрутизаторов.
    </li>
    <li>Обновите наше приложение, чтобы использовать один из этих маршрутизаторов и следовать
        структуре маршрутизации RESTful.</li>
</ul>

<h2>Глава 7.1. Установка маршрутизатора</h2>
<p>Существует буквально сотни сторонних маршрутизаторов, из которых можно выбрать Go. И (к счастью или
    сожалению, в зависимости от вашей точки зрения) все они работают немного по-разному. У них
    разные API, разная логика сопоставления маршрутов и разные особенности поведения.
    </p>
<p>Из всех сторонних маршрутизаторов, которые я пробовал, есть два, которые я бы порекомендовал в качестве
    отправной точки: Pat и Gorilla Mux. Оба имеют хорошую документацию, приличное тестовое покрытие
    и очень хорошо работают со стандартными шаблонами для обработчиков и промежуточного ПО, которые мы использовали
    в этой книге.</p>
<ul>
    <li>bmizerany/pat — более сфокусированный и легкий из двух пакетов. Это обеспечивает
        маршрутизация на основе методов и поддержка семантических URL-адресов… и не более того. Но он надежен
        в том, что он делает, имеет элегантный API, а сам код очень понятен и хорошо написан. Возможным
        недостатком является то, что пакет больше не поддерживается.</li>
    <li>gorilla/mux гораздо более полнофункциональный. В дополнение к маршрутизации на основе методов и
        поддержке семантических URL-адресов вы можете использовать его для маршрутизации на основе схемы, хоста и заголовков.
        Также поддерживаются шаблоны регулярных выражений в URL-адресах. Недостатком пакета является
        то, что он сравнительно медленный и потребляет много памяти, но для веб-
        приложения, управляемого базой данных, такого как наше, влияние на время существования всего HTTP-запроса, вероятно, будет
        небольшим.</li>
</ul>

<p>Для веб-приложения, которое мы создаем, наши потребности просты, и более продвинутые
    функции, которые предлагает Gorilla Mux, просто не требуются. Итак, из двух пакетов мы
    выберем Пэт.</p>
<p>На момент написания для пакета bmizerany/pat не было
    доступных выпусков с семантической версией. Итак, если вы следуете за нами, продолжайте и установите последнюю версию следующим образом:
</p>
<pre><code class="terminal">$ go get github.com/bmizerany/pat
go: downloading github.com/bmizerany/pat v0.0.0-20170815010413-6226ea591a40</code></pre>

<h3>Альтернативные маршрутизаторы</h3>
<p>Я предложил два маршрутизатора выше в качестве отправной точки, но если вы хотите изучить еще несколько
    альтернатив, я бы предложил рассмотреть следующие варианты — все они хороши сами по себе — чтобы увидеть, подходят ли они вам. и ваш конкретный проект.</p>
<ul>
    <li>go-zoo/bone предоставляет функциональность, аналогичную Pat, но с дополнительными удобными функциями
        для регистрации функций-обработчиков и поддержкой маршрутов на основе регулярных выражений. Недостатком
        является то, что на момент написания статьи тестовое покрытие пакета все еще было
        неполным.</li>
    <li>julienschmidt/httprouter — это известный быстрый маршрутизатор на основе radix-tree, который поддерживает
        маршрутизацию на основе методов и семантические URL-адреса. Однако он не может справиться с конфликтующими
        шаблонами, вызванными подстановочными параметрами, что может быть проблемой для приложений,
        использующих схему маршрутизации RESTful (в нашем случае /snippet/create и /snippet/:id —
        конфликтующие шаблоны). Если это не относится к вам, это хороший выбор.</li>
</ul>

<p class="note">Совет. Если вы используете julienschmidt/httprouter,
    методы Router.Handler() и Router.HandlerFunc() совместимы со стандартным ПО промежуточного слоя
    и шаблонами обработчиков Go.</p>
<ul>
    <li>dimfeld/httptreemux — это еще один маршрутизатор на основе radix-tree, но он спроектирован так, чтобы не
        страдать от проблемы конфликтующих шаблонов, которая есть у julienschmidt/httprouter. Недостатком
        является то, что он позволяет регистрировать только объекты http.HandlerFunc, а не
        объекты http.Handler, что означает, что он плохо работает с промежуточным программным обеспечением для конкретных маршрутов,
        использующим стандартный шаблон, который мы описали ранее.</li>
    <li>go-chi/chi — еще один популярный вариант, который использует систему счисления для сопоставления с образцом и
        имеет хороший гибкий API. Примечательно, что он также включает в себя подпакет go-chi/chi/middleware,
        содержащий ряд полезных промежуточных программ.</li>
</ul>

<h2>Глава 7.2. Реализация маршрутов RESTful</h2>
<p>Базовый синтаксис для создания маршрутизатора и регистрации маршрута с помощью
    пакета bmizerany/pat выглядит следующим образом:</p>

<pre><code>mux := pat.New()
mux.Get("/snippet/:id", http.HandlerFunc(app.showSnippet))</code></pre>

<p>В этом коде:</p>
<ul>
    <li>Шаблон «/snippet/:id» включает именованный захват :id. Именованный захват действует как
        подстановочный знак, тогда как остальная часть шаблона совпадает буквально. Пэт незаметно добавит содержимое
        именованного захвата в строку запроса URL во время выполнения.</li>
    <li>Метод mux.Get() используется для регистрации шаблона URL и обработчика, который будет вызываться
        только в том случае, если запрос имеет HTTP-метод GET.Также предусмотрены соответствующие методы Post(), 
        Put(), Delete() и другие.</li>
    <li>Pat не позволяет нам напрямую регистрировать функции-обработчики, поэтому вам нужно преобразовать их
        с помощью адаптера http.HandlerFunc().</li>
</ul>

<p>Имея все это в виду, давайте перейдем к файлу route.go и обновим его, чтобы использовать Pat:</p>
<pre><code>File: cmd/web/routes.go

    package main

    import (
        "net/http"
        "github.com/bmizerany/pat" // Новый импорт
        "github.com/justinas/alice"
    )
    func (app *application) routes() http.Handler {
        standardMiddleware := alice.New(app.recoverPanic, app.logRequest, secureHeaders)
        mux := pat.New()
        mux.Get("/", http.HandlerFunc(app.home))
        mux.Get("/snippet/create", http.HandlerFunc(app.createSnippetForm))
        mux.Post("/snippet/create", http.HandlerFunc(app.createSnippet))
        mux.Get("/snippet/:id", http.HandlerFunc(app.showSnippet)) // Перемещено вниз
        fileServer := http.FileServer(http.Dir("./ui/static/"))
        mux.Get("/static/", http.StripPrefix("/static", fileServer))
        return standardMiddleware.Then(mux)
    }</code></pre>
<p>Здесь следует отметить несколько важных вещей.</p>
<ul>
    <li>Пэт сопоставляет шаблоны в том порядке, в котором они зарегистрированы. В нашем приложении HTTP-
        запрос GET «/snippet/create» на самом деле является допустимым совпадением для двух маршрутов — это точное
        совпадение для /snippet/create и совпадение с подстановочным знаком для /snippet/:id (часть «создать
        » пути будет рассматриваться как параметр :id). Таким образом, чтобы убедиться, что точное
        совпадение имеет преимущество, нам нужно зарегистрировать маршруты с точным соответствием перед любыми
        маршрутами с подстановочными знаками.</li>
    <li>Шаблоны URL-адресов, заканчивающиеся косой чертой (например, «/static/»), работают так же, как и
        встроенный в Go сервисмультиплексор. Любой запрос, соответствующий началу шаблона, будет
        отправлен соответствующему обработчику.</li>
    <li>Шаблон «/» — это особый случай.
        точно "/".</li>
</ul>
<p>Имея это в виду, мы также должны внести несколько изменений в наш
    файл handlers.go:</p>
<pre><code>File: cmd/web/handlers.go

    package main
    ...
    
    func (app *application) home(w http.ResponseWriter, r *http.Request) {
        // Поскольку Пэт точно соответствует пути "/", теперь мы можем удалить ручную проверку
        // r.URL.Path != "/" из этого обработчика.
        s, err := app.snippets.Latest()
        if err != nil {
            app.serverError(w, err)
            return
        }
        app.render(w, r, "home.page.tmpl", &templateData{
            Snippets: s,
        })
    }

    func (app *application) showSnippet(w http.ResponseWriter, r *http.Request) {
        // Pat не удаляет двоеточие из именованного ключа захвата, поэтому нам нужно
        // получить значение ":id" из строки запроса вместо "id".
        id, err := strconv.Atoi(r.URL.Query().Get(":id"))
        if err != nil || id < 1 {
            app.notFound(w)
            return
        }
        s, err := app.snippets.Get(id)
        if err != nil {
            if errors.Is(err, models.ErrNoRecord) {
                app.notFound(w)
            } else {
                app.serverError(w, err)
            }
            return
            }
        app.render(w, r, "show.page.tmpl", &templateData{
            Snippet: s,
        })
    }

    // Добавляем новый обработчик createSnippetForm, который на данный момент возвращает ответ-заполнитель.
    func (app *application) createSnippetForm(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Create a new snippet..."))
    }

    func (app *application) createSnippet(w http.ResponseWriter, r *http.Request) {
        // Проверка того, является ли метод запроса POST, теперь излишне и
        // может быть удалена.
        title := "O snail"
        content := "O snail\nClimb Mount Fuji,\nBut slowly, slowly!\n\n– Kobayashi Issa"
        expires := "7"
        id, err := app.snippets.Insert(title, content, expires)
        if err != nil {
            app.serverError(w, err)
            return
        }

        // Измените перенаправление, чтобы использовать новый семантический стиль URL /snippet/:id
        http.Redirect(w, r, fmt.Sprintf("/snippet/%d", id), http.StatusSeeOther)
    }</code></pre>
<p>Наконец, нам нужно обновить таблицу в нашем файле home.page.tmpl, чтобы ссылки в HTML
    также использовали новый семантический стиль URL-адреса /snippet/:id.</p>
<pre><code>
    {{template "base" .}}

    {{define "title"}}Home{{end}}
    
    {{define "main"}}
        &lt;h2&gt;Latest Snippets&lt;/h2&gt;
        {{if .Snippets}}
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th&gt;Title&lt;/th&gt;
                &lt;th&gt;Created&lt;/th&gt;
                &lt;th&gt;ID&lt;/th&gt;
            &lt;/tr&gt;
            {{range .Snippets}}
            &lt;tr&gt;
                &lt;!-- Use the new semantic URL style--&gt;
                &lt;td&gt;&lt;a href='/snippet/{{.ID}}'&gt;{{.Title}}&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;{{humanDate .Created}}&lt;/td&gt;
                &lt;td&gt;#{{.ID}}&lt;/td&gt;
            &lt;/tr&gt;
            {{end}}
        &lt;/table&gt;
        {{else}}
            &lt;p&gt;There's nothing to see here... yet!&lt;/p&gt;
        {{end}}
    {{end}}</code></pre>

<p>После этого перезапустите приложение, и теперь вы сможете просматривать
    фрагменты текста через семантические URL-адреса. Например: http://localhost:4000/snippet/1.</p>
<p><img src="static/images/picture7.1.png"/></p>
<p>Вы также можете видеть, что запросы с использованием неподдерживаемого метода HTTP встречаются с
    ответом 405 Method Not Allowed. Например, попробуйте сделать POST-запрос к тому же
    URL-адресу с помощью curl:</p>
<pre><code class="terminal">$ curl -I -X POST http://localhost:4000/snippet/1
    HTTP/1.1 405 Method Not Allowed
    Allow: HEAD, GET
    Content-Type: text/plain; charset=utf-8
    X-Content-Type-Options: nosniff
    X-Frame-Options: deny
    X-Xss-Protection: 1; mode=block
    Date: Mon, 23 Jul 2018 10:10:33 GMT
    Content-Length: 19</code></pre>

<p>Конец главы 7.</p>
</body>
</html>