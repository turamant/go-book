<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 2</title>
</head>
<body> 
<h1>Обслуживание статических файлов</h1>
<p>Теперь давайте улучшим внешний вид домашней страницы, добавив
    в наш проект несколько статических файлов CSS и изображений, а также немного кода JavaScript, чтобы выделить активный
    элемент навигации.</p>
<p>Если вы следуете инструкциям, вы можете взять необходимые файлы и извлечь их в
    папку ui/static, которую мы создали ранее, с помощью следующих команд:    
</p>
<pre><code>$ cd $HOME/code/snippetbox
    $ curl https://www.turamant.net/static/sb.v130.tar.gz | tar -xvz -C ./ui/static/</code></pre>
<p>Содержимое вашего каталога ui/static теперь должно выглядеть так:</p>    
<p><img src="static/images/picture2.11.png"/></p>
<h2>Обработчик http.FileServer</h2>
<p>Пакет net/http Go поставляется со встроенным обработчиком http.FileServer, который вы можете использовать для
    обслуживания файлов по HTTP из определенного каталога. Давайте добавим в наше приложение новый маршрут, чтобы
    все запросы, начинающиеся с «/static/», обрабатывались с его помощью, например:</p>

<table>
    <tr>
        <th>Method</th>
        <th>Шаблон</th>
        <th>Handler</th>
        <th>Действие</th>
    </tr>
    <tr>
        <td>Любой</td>
        <td>/</td>
        <td>home</td>
        <td>Показать домашнюю страницу</td>
    </tr>
    <tr>
        <td>Любой</td>
        <td>/snippet?id=1</td>
        <td>showSnippet</td>
        <td>Показать определенный фрагмент</td>
    </tr>
    <tr>
        <td>POST</td>
        <td>/snippet/create</td>
        <td>createSnippet</td>
        <td>Создать новый фрагмент</td>
    </tr>
    <tr>
        <td>Любой</td>
        <td>/static/</td>
        <td>http.FileServer</td>
        <td>Показать определенный статический файл</td>
    </tr>  
</table>
<p class="note">Помните: шаблон «/static/» — это шаблон пути к поддереву, поэтому он действует так же, как
    если бы в конце был подстановочный знак.</p>
<p>Чтобы создать новый обработчик http.FileServer, нам нужно использовать функцию http.FileServer(),
    подобную этой</p>
<pre><code>fileServer := http.FileServer(http.Dir("./ui/static"))</code></pre>
<p>Когда этот обработчик получает запрос, он удаляет начальную косую черту из пути URL-адреса
    , а затем ищет в каталоге ./ui/static соответствующий файл для отправки пользователю.</p>
<p>Итак, чтобы это работало правильно, мы должны удалить начальный «/ static» из пути URL-адреса, прежде чем
    передавать его в http.FileServer. В противном случае он будет искать файл, которого не существует, и
    пользователь получит ответ 404: страница не найдена. К счастью, в Go есть
    помощник http.StripPrefix() специально для этой задачи.</p>
<p>Откройте файл main.go и добавьте следующий код, чтобы файл в итоге выглядел так:</p>
<pre><code>File: cmd/web/main.go
    package main
    import (
    "log"
    "net/http"
    )
    func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", home)
    mux.HandleFunc("/snippet", showSnippet)
    mux.HandleFunc("/snippet/create", createSnippet)
    // Create a file server which serves files out of the "./ui/static" directory.
    // Note that the path given to the http.Dir function is relative to the project
    // directory root.
    fileServer := http.FileServer(http.Dir("./ui/static/"))
    // Use the mux.Handle() function to register the file server as the handler for
    // all URL paths that start with "/static/". For matching paths, we strip the
    // "/static" prefix before the request reaches the file server.
    mux.Handle("/static/", http.StripPrefix("/static", fileServer))
    log.Println("Starting server on :4000")
    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}</code></pre>
<p>После этого перезапустите приложение и откройте http://localhost:4000/static/ в
    браузере. Вы должны увидеть список папок ui/static с возможностью навигации, который
    выглядит следующим образом:</p>
<p><img src="static/images/picture2.12.png"/></p>
<p>Не стесняйтесь поиграть и просмотреть список каталогов, чтобы просмотреть отдельные
    файлы. Например, если вы перейдете на http://localhost:4000/static/css/main.css, вы
    увидите, что файл CSS появится в вашем браузере следующим образом:</p>
<p><img src="static/images/picture2.13.png"/></p>
<h2>Использование статических файлов</h2>
<p>Теперь, когда файловый сервер работает правильно, мы можем обновить
    файл ui/html/base.layout.tmpl, чтобы использовать статические файлы:
</p>
<pre><code>File: ui/html/base.layout.tmpl
{{define "base"}}
&lt;!doctype html&gt;
&lt;html lang='en'&gt;
    &lt;head&gt;
        &lt;meta charset='utf-8'&gt;
        &lt;title&gt;{{template "title" .}} - Snippetbox&lt;/title&gt;
        &lt;!-- Link to the CSS stylesheet and favicon --&gt;
        &lt;link rel='stylesheet' href='/static/css/main.css'&gt;
        &lt;link rel='shortcut icon' href='/static/img/favicon.ico' type='image/x-icon'&gt;
        &lt;!-- Also link to some fonts hosted by Google --&gt;
        &lt;link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700'&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;&lt;a href='/'&gt;Snippetbox&lt;/a&gt;&lt;/h1&gt;
        &lt;/header&gt;
        &lt;nav&gt;
            &lt;a href='/'&gt;Home&lt;/a&gt;
        &lt;/nav&gt;
        &lt;main&gt;
            {{template "main" .}}
        &lt;/main&gt;
            {{template "footer" .}}
        &lt;!-- And include the JavaScript file --&gt;
        &lt;script src="/static/js/main.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
{{end}}</code></pre>
<p>Убедитесь, что вы сохранили изменения, а затем посетите http://localhost:4000. Теперь ваша домашняя страница должна
    выглядеть так:</p>
<p><img src="static/images/picture2.14.png"/></p>
<h2>Дополнительные сведения</h2>
<h3>Возможности и функции</h3>
<li>Файловый сервер Go имеет несколько действительно приятных функций, о которых стоит упомянуть:
    Он очищает все пути запросов, пропуская их через функцию path.Clean() перед
    поиском файла. Это удаляет любой . и .. элементы из пути URL, что помогает
    остановить атаки обхода каталога. Эта функция особенно полезна, если вы используете
    файловый сервер в сочетании с маршрутизатором, который не очищает URL-адреса автоматически.
</li>
<li>Запросы диапазона полностью поддерживаются. Это замечательно, если ваше приложение обслуживает большие файлы
    и вы хотите поддерживать возобновляемые загрузки. Вы можете увидеть эту функциональность в действии, если
    вы используете curl для запроса байтов 100-199 файла logo.png, например:
</li>
<pre><code>$ curl -i -H "Range: bytes=100-199" --output - http://localhost:4000/static/img/logo.png
    HTTP/1.1 206 Partial Content
    Accept-Ranges: bytes
    Content-Length: 100
    Content-Range: bytes 100-199/1075
    Content-Type: image/png
    Last-Modified: Thu, 04 May 2017 13:07:52 GMT
    Date: Wed, 08 Aug 2023 16:21:16 GMT
    [binary data]
</code></pre>
<li>Заголовки Last-Modified и If-Modified-Since поддерживаются прозрачно. Если
    файл не изменился с момента последнего запроса пользователя, то http.FileServer отправит
    код состояния 304 Not Modified вместо самого файла. Это помогает уменьшить задержку и
    накладные расходы на обработку как для клиента, так и для сервера.
</li>
<li>Content-Type автоматически устанавливается из расширения файла с помощью
    функции mime.TypeByExtension(). Вы можете добавить свои собственные расширения и
    типы контента, используя функцию mime.AddExtensionType(), если это необходимо. 0-199 файла logo.png, например:
</li>
<h2>Производительность</h2>
<p>В приведенном выше коде мы настроили наш файловый сервер так, чтобы он обслуживал файлы из
    каталога ./ui/static на вашем жестком диске.</p>
<p>Но важно отметить, что после запуска приложения http.FileServer,
    вероятно, не будет читать эти файлы с диска. Как Windows, так и операционные системы на основе Unix
    кэшируют недавно использованные файлы в ОЗУ, поэтому (по крайней мере, для часто обслуживаемых файлов) вполне вероятно,
    что http.FileServer будет обслуживать их из ОЗУ, а не выполнять относительно медленный
    обмен данными с вашим жестким диском. диск.</p>
<h2>Обслуживание отдельных файлов</h2>
<p>Иногда вам может понадобиться обслуживать один файл из обработчика. Для этого есть
    функция http.ServeFile(), которую вы можете использовать так:
</p>
<pre><code>func downloadHandler(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, "./ui/static/file.zip")
}</code></pre>
<p class="note">Предупреждение: http.ServeFile() не очищает путь к файлу автоматически. Если вы
    строите путь к файлу из ненадежного пользовательского ввода, чтобы избежать атак с обходом каталога,
    вы должны дезинфицировать ввод с помощью filepath.Clean() перед его использованием.</p>
<h2>Отключение списков каталогов</h2>
<p>Если вы хотите отключить списки каталогов, вы можете воспользоваться несколькими способами.
    Самый простой способ? Добавьте пустой файл index.html в определенный каталог,
    для которого вы хотите отключить списки. Затем он будет подаваться вместо списка каталогов, и пользователь получит
    ответ 200 OK без тела. Если вы хотите сделать это для всех каталогов в
    ./ui/static, вы можете использовать команду:
</p> 
<pre><code>$ find ./ui/static -type d -exec touch {}/index.html \;</code></pre>
<p>Более сложное (но, возможно, лучшее) решение — создать пользовательскую реализацию http.FileSystem
    и заставить ее возвращать ошибку os.ErrNotExist для любых каталогов. Полное
    объяснение и пример кода можно найти в этом сообщении блога.</p>  
 
</body>
</html>