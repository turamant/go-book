<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 10</title>
</head>
<body>
<h1>Глава 10. Улучшения безопасности</h1>
<p>В этом разделе книги мы собираемся внести некоторые улучшения в наше приложение, чтобы
    наши данные оставались в безопасности во время передачи, а наш сервер мог лучше справляться с некоторыми
    распространенными типами атак типа «отказ в обслуживании».</p>
<p>Вы узнаете:</p>
<ul>
    <li>Как быстро и легко создать самозаверяющий сертификат TLS, используя только Go.</li>
    <li>Основы настройки вашего приложения для
        безопасной обработки всех запросов и ответов через HTTPS.</li>
    <li>Некоторые разумные изменения в настройках TLS по умолчанию, которые помогут обеспечить безопасность пользовательской информации
        и быструю работу нашего сервера.</li>
    <li>Как установить таймауты соединения на нашем сервере, чтобы смягчить
        атаки <span>Slowloris</span> и других атак на медленный клиент.</li>
</ul>

<h2>10.1 Создание самоподписанного сертификата TLS</h2>
<p>HTTPS — это, по сути, HTTP, передаваемый через соединение TLS (Transport Layer Security). Поскольку
    данные передаются через соединение TLS, они шифруются и подписываются, что помогает обеспечить их
    конфиденциальность и целостность во время передачи.</p>
<p>Если вы не знакомы с этим термином, TLS — это, по сути, современная версия SSL (Secure
    Sockets Layer). SSL теперь официально объявлен устаревшим из соображений безопасности, но это
    имя все еще живет в общественном сознании и часто используется для взаимодействия с TLS. Для
    ясности и точности на протяжении всей книги мы будем использовать термин TLS.</p>
<p>Прежде чем наш сервер сможет начать использовать HTTPS, нам необходимо сгенерировать сертификат TLS.
    Для производственных серверов я рекомендую использовать Let's Encrypt для создания сертификатов TLS, но
    в целях разработки проще всего создать собственный самозаверяющий
    сертификат.</p>
<p>Самозаверяющий сертификат аналогичен обычному сертификату TLS, за исключением того, что он не
    подписан криптографически доверенным центром сертификации. Это означает, что ваш веб-
    браузер выдаст предупреждение при первом использовании, но, тем не менее, он будет
    правильно шифровать HTTPS-трафик и подходит для целей разработки и тестирования.</p>
<p>Удобно, что пакет crypto/tls в стандартной библиотеке Go включает инструментgenerate_cert.go,
    который мы можем использовать для легкого создания собственного самозаверяющего сертификата.</p>
<p>Если вы следуете инструкциям, сначала создайте новый каталог tls в корне
    репозитория вашего проекта, чтобы хранить сертификат и перейти в него:</p>
<p class="terminal">
    $ cd $HOME/code/snippetbox
    $ mkdir tls
    $ cd tls

</p>
<p>Чтобы запустить инструмент <span>generate_cert.go</span>, вам необходимо знать место на вашем компьютере, где
    установлен исходный код стандартной библиотеки Go. Если вы используете Linux, macOS или
    FreeBSD и следовали официальным инструкциям по установке, файл <span>gener_cert.go</span>
    должен находиться в каталоге <span>/usr/local/go/src/crypto/tls</span>.</p>
<p>Если вы используете macOS и установили Go с помощью Homebrew, файл, вероятно, будет находиться в
    /usr/local/Cellar/go/./libexec/src/crypto/tls/generate_cert.go или
    аналогичный путь.</p>
<p>Как только вы узнаете, где он находится, вы можете запустить инструмент <span>generate_cert.go</span> следующим образом:</p>
<p class="terminal">
    $ go run /usr/local/go/src/crypto/tls/generate_cert.go --rsa-bits=2048 --host=localhost

        2023/10/16 11:50:14 wrote cert.pem
        2018/10/16 11:50:14 wrote key.pem
</p>
<p>За кулисами инструментgenerate_cert.go работает в два этапа:</p>
<ol>
    <li> Сначала он генерирует 2048-битную пару ключей RSA, которая представляет собой криптографически безопасный открытый ключ
        и закрытый ключ.</li>
    <li>Затем он сохраняет закрытый ключ в файле key.pem и генерирует самозаверяющий сертификат TLS
        для локального хоста, содержащий открытый ключ, который он сохраняет в файле cert.pem.
        И закрытый ключ, и сертификат имеют кодировку PEM, которая является стандартным форматом, используемым
        в большинстве реализаций TLS.Затем он сохраняет закрытый ключ в файле key.pem и генерирует самозаверяющий сертификат TLS
        для локального хоста, содержащий открытый ключ, который он сохраняет в файле cert.pem.
        И закрытый ключ, и сертификат имеют кодировку PEM, которая является стандартным форматом, используемым
        в большинстве реализаций TLS.</li>
</ol>
<p>Репозиторий вашего проекта теперь должен выглядеть примерно так:</p>
<p><img src="static/images/picture10.1.png"</p>
<p>Вот и все! Теперь у нас есть самоподписанный сертификат TLS (и соответствующий закрытый ключ)
    , который мы можем использовать во время разработки.</p>


<h2>10.2 Запуск HTTPS-сервера</h2>
<p>Теперь у нас есть самозаверяющий сертификат TLS и соответствующий закрытый ключ. Запуск
    веб-сервера HTTPS прекрасен и прост — нам просто нужно открыть файл main.go и заменить
    метод srv.ListenAndServe() на srv.ListenAndServeTLS().</p>
<p>Измените файл main.go так, чтобы он соответствовал следующему коду:</p>
<pre><code>
File: cmd/web/main.go

package main
...

func main() {
    dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "MySQL data source name")
    addr := flag.String("addr", ":4000", "HTTP network address")
    secret := flag.String("secret", "s6Ndh+pPbnzHbS*+9Pk8qGWhTzbpa@ge", "Secret key")
    flag.Parse()
    
    infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
    errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)
    
    db, err := openDB(*dsn)
    
    if err != nil {
        errorLog.Fatal(err)
    }
    defer db.Close()
    
    templateCache, err := newTemplateCache("./ui/html/")
    if err != nil {
        errorLog.Fatal(err)
    }
    
    session := sessions.New([]byte(*secret))
    session.Lifetime = 12 * time.Hour
    session.Secure = true // Установите флажок «Безопасно» для наших файлов cookie сеанса.
    
    app := &application{
        errorLog: errorLog,
        infoLog: infoLog,
        session: session,
        snippets: &mysql.SnippetModel{DB: db},
        templateCache: templateCache,
    }
    srv := &http.Server{
        Addr: *addr,
        ErrorLog: errorLog,
        Handler: app.routes(),
    }
    
    infoLog.Printf("Starting server on %s", *addr)
    
    // Используйте метод ListenAndServeTLS() для запуска HTTPS-сервера. Мы
    // передаем пути к сертификату TLS и соответствующему закрытому ключу в качестве
    // двух параметров.
    err = srv.ListenAndServeTLS("./tls/cert.pem", "./tls/key.pem")
    errorLog.Fatal(err)
}
...
</code></pre>
<p>Когда мы запустим это, наш сервер по-прежнему будет прослушивать порт 4000 — с той лишь разницей, что
    теперь он будет использовать HTTPS вместо HTTP.</p>
<p>Продолжайте и запустите его как обычно:</p>
<p class="terminal">
    $ cd $HOME/code/snippetbox
    $ go run ./cmd/web
    
    INFO 2023/10/16 12:14:28 Starting server on :4000

</p>
<p>Если вы откроете веб-браузер и посетите <span>https://localhost:4000/</span>, вы, вероятно, получите
    предупреждение браузера, подобное показанному на снимке экрана ниже.</p>
<p><img src="static/images/picture10.2.png"</p>
<p>Если вы используете Firefox, как и я, нажмите «Дополнительно», затем «Добавить исключение», а в появившемся диалоговом окне нажмите «Подтвердить исключение безопасности».</p>

<p><img src="static/images/picture10.3.png"</p>
<p>Если вы используете Chrome или Chromium, нажмите «Дополнительно», а затем
    ссылку «Перейти на локальный хост».</p>
<p>После этого должна появиться домашняя страница приложения (хотя в строке URL-адреса по-прежнему будет отображаться предупреждение,
    поскольку сертификат TLS является самоподписанным).</p>
<p>В Firefox это должно выглядеть примерно так:</p>
<p><img src="static/images/picture10.4.png"</p>
<p>Если вы используете Firefox, я рекомендую нажать Ctrl+i, чтобы просмотреть информацию о вашей
    домашней странице:</p>
<p><img src="static/images/picture10.5.png"</p>
<p>Раздел «Технические сведения» подтверждает, что наше соединение зашифровано и работает
    должным образом.</p>
<p>В моем случае я вижу, что используется TLS версии 1.2, а набор шифров для моего HTTPS-
    соединения — TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256. Мы поговорим подробнее о
    наборах шифров в следующей главе.</p>
<p class="note">
    Примечание: если вам интересно, кто или что такое «Acme Co», то это просто жестко запрограммированное
имя-заполнитель, которое использует инструмент generate_cert.go.
</p>

<h3>Дополнительная информация</h3>
<h4>HTTP-запросы</h4>
<p>Важно отметить, что наш HTTPS-сервер поддерживает только HTTPS. Если вы попытаетесь сделать к нему обычный
    HTTP-запрос, это не сработает. Но то, что именно произойдет, зависит от версии Go
    , которую вы используете.</p>
<p>В версии Go 1.12 и новее сервер отправит пользователю статус 400 Bad Request и
    сообщение «Клиент отправил HTTP-запрос на HTTPS-сервер». Ничего не будет
    зарегистрировано.</p>
<p>В более старых версиях Go сервер записывает байты 15 03 01 00 02 02 0A в
    базовое TCP-соединение, что по сути означает «я не понимаю» в TLS, и
    вы также увидите соответствующее сообщение журнала. в вашем терминале примерно так:</p>
<p class="terminal">
    ERROR 2018/10/16 12:36:53 server.go:2977: http: TLS handshake error from [::1]:49544: tls: first record does not look like 
</p>

<h3>Соединения HTTP/2</h3>
<p>Большим плюсом использования HTTPS является то, что — если клиент поддерживает соединения HTTP/2 — HTTPS-
    сервер Go автоматически обновит соединение для использования HTTP/2.</p>
<p>Это хорошо, потому что в конечном итоге наши страницы будут загружаться для пользователей быстрее. Если вы
    не знакомы с HTTP/2, вы можете получить краткое представление об основах и о том, как это было
    реализовано за кулисами, в выступлении Брэда Фитцпатрика на встрече GoSF.</p>
<p>Если вы используете актуальную версию Firefox, вы сможете увидеть это в действии.
<p>Нажмите Ctrl+Shift+E, чтобы открыть инструменты разработчика, и если вы посмотрите на заголовки домашней
    страницы, вы увидите, что используемый протокол — HTTP/2.</p>

<p><img src="static/images/picture10.6.png"</p>

<h3>Разрешения сертификата.</h3>
<p>Важно отметить, что пользователь, которого вы используете для запуска приложения Go, должен иметь
    разрешения на чтение как для файлов <span>cert.pem</span>, так и для файлов <span>key.pem</span>, в противном случае ListenAndServeTLS()
    вернет ошибку отказа в разрешении.</p>
<p>По умолчанию инструмент generate_cert.go предоставляет разрешение на чтение
    файла <span>cert.pem</span> всем пользователям, но разрешение на чтение только владельцу файла <span>key.pem</span>. В моем случае разрешения
    выглядят так:</p>
<p class="terminal">
    $ cd $HOME/code/snippetbox/tls
    $ ls -l
    
    total 8
    -rw-r--r-- 1 alex alex 1090 Oct 16 11:50 cert.pem
    -rw------- 1 alex alex 1679 Oct 16 11:50 key.pem

</p>
<p>Как правило, рекомендуется максимально строго ограничить права доступа к вашим закрытым ключам
    и разрешить их чтение только владельцу или определенной группе.</p>

<h3>Управления источником</h3>
<p>Если вы используете систему контроля версий (например, Git или Mercurial), вы можете добавить
    правило игнорирования, чтобы содержимое каталога tls не было случайно зафиксировано. Например , с Git:</p>
<p class="terminal">
    $ cd $HOME/code/snippetbox
    $ echo 'tls/' >> .gitignore

</p>

<h2>Глава 10.3. Настройка параметров HTTPS</h2>
<p>Go имеет довольно хорошие настройки по умолчанию для своего HTTPS-сервера, но мы можем внести несколько улучшений и оптимизаций.
    Если вы новичок в HTTPS и TLS, я рекомендую потратить некоторое время на понимание
    принципов, лежащих в основе TLS, прежде чем начинать изменять настройки по умолчанию. Чтобы помочь, я включил
    в приложение общее описание того, как работает TLS, которое я рекомендую прочитать, прежде чем
    продолжить.</p>
<p>Но если отбросить это предостережение, есть пара настроек, которые почти всегда полезно внести.</p>
<p>Чтобы изменить настройки TLS по умолчанию, нам нужно сделать две вещи:</p>
<ol>
    <li>во-первых, нам нужно создать структуру tls.Config, которая содержит настройки TLS, отличные от настроек по умолчанию,
        которые мы хотим использовать.</li>
    <li>Во-вторых, нам нужно добавить это в нашу структуру http.Server перед запуском сервера.</li>
</ol>    
<p>Я продемонстрирую:</p>
<pre><code>
File: cmd/web/main.go

package main

import (
    "crypto/tls" // New import
    "database/sql"
    "flag"
    "html/template"
    "log"
    "net/http"
    "os"
    "time"
    "turamant.net/snippetbox/pkg/models/mysql"
    _ "github.com/go-sql-driver/mysql"
    "github.com/golangcollege/sessions"
)
...

func main() {
    ...
    app := &application{
        errorLog: errorLog,
        infoLog: infoLog,
        session: session,
        snippets: &mysql.SnippetModel{DB: db},
        templateCache: templateCache,
    }

    // Инициализируйте структуру tls.Config для хранения нестандартных настроек TLS, которые мы хотим
    // использовать сервером.
    tlsConfig := &tls.Config{
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{tls.X25519, tls.CurveP256},
    }

    // Задайте в поле TLSConfig сервера использование только что
    // созданной переменной tlsConfig.
    srv := &http.Server{
        Addr: *addr,
        ErrorLog: errorLog,
        Handler: app.routes(),
        TLSConfig: tlsConfig,
    }

    infoLog.Printf("Starting server on %s", *addr)
    err = srv.ListenAndServeTLS("./tls/cert.pem", "./tls/key.pem")
    errorLog.Fatal(err)
    }
...
</code></pre>
<p>В структуре tls.Config мы использовали две настройки:</p>

<ul>
    <li><span>Поле tls.Config.PreferServerCipherSuites</span> определяет, должно ли HTTPS-
        соединение использовать предпочтительные наборы шифров Go или предпочтительные наборы шифров пользователя. Установив
        для этого параметра значение true — как мы уже сделали выше — предпочтительные наборы шифров Go получают
        предпочтение, и мы помогаем повысить вероятность
        использования стойкого набора шифров, который также поддерживает прямую секретность.</li>
    <li><span>Поле tls.Config.CurvePreferences</span> позволяет нам указать, каким эллиптическим кривым следует
        отдавать предпочтение во время подтверждения TLS. Go поддерживает несколько эллиптических кривых, но начиная с
        Go 1.11 только tls.CurveP256 и tls.X25519 имеют реализации на ассемблере. Остальные
        очень требовательны к процессору, поэтому их исключение помогает гарантировать, что наш сервер останется
        производительным при больших нагрузках.</li>
</ul>

<h3>Дополнительная информация</h3>
<h4>Ограничение наборов шифров</h4>
<p>Полный набор наборов шифров, поддерживаемых Go, определен в
    константах пакета crypto/tls.</p>
<p>Для некоторых приложений может быть желательно ограничить поддержку вашего HTTPS-сервера только некоторыми
    из этих наборов шифров. Например, вы можете захотеть поддерживать только комплекты шифров, использующие
    ECDHE (прямая секретность), и не поддерживать комплекты слабых шифров, использующие RC4, 3DES или CBC. Вы
    можете сделать это через поле tls.Config.CipherSuites следующим образом:</p>

<pre><code>
    tlsConfig := &tls.Config{
        PreferServerCipherSuites: true,
        CipherSuites: []uint16{
        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
        tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        },
    }
</code></pre>
<p class="note">
    Важно! Ограничение поддерживаемых наборов шифров только надежными и современными
шифрами может означать, что пользователи некоторых старых браузеров не смогут использовать ваш
веб-сайт. Необходимо найти баланс между безопасностью и обратной совместимостью, и правильное решение для вас будет зависеть от технологии, обычно
используемой вашей пользовательской базой. Рекомендуемые Mozilla конфигурации для современных,
средних и старых браузеров могут помочь вам принять решение.
</p>
<p>Если для параметра PreferServerCipherSuites также установлено значение true, как в приведенном выше коде, то
    порядок элементов в поле CipherSuites важен — наборы шифров, которые
    идут первыми в срезе, будут предпочтительными.</p>
<h4>Версии TLS Версии</h4>
<p>TLS также определяются как константы в пакете crypto/tls, а HTTPS-
    сервер Go поддерживает версии TLS от 1.0 до 1.3.</p>
<p>Вы можете настроить минимальную и максимальную версии TLS с помощью
    полей tls.Config.MinVersion и MaxVersion. Например, если вы знаете, что все компьютеры
    в вашей пользовательской базе поддерживают TLS 1.2, но не TLS 1.3, вы можете использовать
    такую ​​конфигурацию:</p>
<pre><code>
    tlsConfig := &tls.Config{
        MinVersion: tls.VersionTLS12,
        MaxVersion: tls.VersionTLS12,
    }
</code></pre>

<h4>TLS 1.3</h4>
<p>Важно (и интересно) отметить, что если согласовано соединение TLS 1.3, любое
    поле CipherSuites в вашем tls.Config будет игнорироваться. Причина этого в том, что все
    наборы шифров, которые Go поддерживает для соединений TLS 1.3, считаются безопасными, поэтому нет
    особого смысла предоставлять механизм для их настройки. Вместо этого выбор шифрования
    будет основан на приоритете клиента или, если для параметра PreferServerCipherSuites установлено значение true,
    приоритет выбора шифрования будет определяться на основе того, что оптимально для вашего серверного оборудования.</p>

<h2>Глава 10.4. Таймауты соединения</h2>
<p>Давайте улучшим отказоустойчивость нашего сервера, добавив некоторые
    настройки таймаута, например:</p>
<pre><code>
File: cmd/web/main.go

package main
...

func main() {
    ...
    tlsConfig := &tls.Config{
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{tls.X25519, tls.CurveP256},
    }

    srv := &http.Server{
        Addr: *addr,
        ErrorLog: errorLog,
        Handler: app.routes(),
        TLSConfig: tlsConfig,
        // Добавьте на сервер таймауты простоя, чтения и записи.
        IdleTimeout: time.Minute,
        ReadTimeout: 5 * time.Second,
        WriteTimeout: 10 * time.Second,
    }
    
    infoLog.Printf("Starting server on %s", *addr)
    err = srv.ListenAndServeTLS("./tls/cert.pem", "./tls/key.pem")
    errorLog.Fatal(err)
    }
...
</code></pre>
<p>Все три таймаута — <span>IdleTimeout, ReadTimeout и WriteTimeout</span> — являются настройками всего сервера, которые действуют на базовое соединение и применяются ко всем запросам независимо
    от их обработчика или URL-адреса.</p>

<h3>Тайм-аут простоя</h3>
<p>По умолчанию Go включает проверку активности для всех принятых соединений. Это помогает уменьшить задержку
    (особенно для соединений HTTPS), поскольку клиент может повторно использовать одно и то же соединение для
    нескольких запросов без необходимости повторять рукопожатие.</p>
<p>Также по умолчанию Go автоматически закрывает соединения поддержки активности после 3 минут
    бездействия. Это помогает очистить соединения, в которых пользователь неожиданно исчез
    (например, из-за отключения электроэнергии на стороне клиента).</p>
<p>Невозможно увеличить это отключение выше 3 минут (если вы не создадите собственный
    net.Listener), но вы можете уменьшить его с помощью настройки IdleTimeout. В нашем случае мы установили значение
    1 минута, что означает, что все соединения, поддерживающие активность, будут автоматически закрыты через 1 минуту.
    минута бездействия.</p>

<h3>Таймаут чтения</h3>
<p>В нашем коде мы также установили для параметра ReadTimeout значение 5 секунд. Это означает, что если
    заголовки или тело запроса все еще читаются через 5 секунд после первого принятия запроса,
    Go закроет базовое соединение. Поскольку это «жесткое» закрытие соединения
    , пользователь не получит никакого ответа HTTP(S).</p>
<p>Установка короткого периода ReadTimeout помогает снизить риск атак медленных клиентов,
    таких как <span>Slowloris</span>, которые в противном случае могут держать соединение открытым на неопределенный срок, отправляя
    частичные, неполные HTTP(S)-запросы.</p>
<p class="note">
    Важно: если вы установили ReadTimeout, но не установили IdleTimeout, то
по умолчанию для IdleTimeout будет использоваться тот же параметр, что и для ReadTimeout. Например, если вы установите ReadTimeout
на 3 секунды, то возникнет побочный эффект, заключающийся в том, что все соединения, поддерживающие активность, также будут
закрыты после 3 секунд бездействия. Как правило, я рекомендую избегать любой
двусмысленности и всегда устанавливать явное значение IdleTimeout для вашего сервера.
</p>

<h3>Таймаут записи.</h3>
<p>Параметр WriteTimeout закроет базовое соединение, если наш сервер попытается выполнить
    запись в соединение через определенный период (в нашем коде 10 секунд). Но это ведет себя
    немного по-разному в зависимости от используемого протокола.</p>
<p>Для HTTP-соединений, если некоторые данные записываются в соединение более чем через 10 секунд
    после завершения чтения заголовка запроса, Go закроет базовое соединение
    вместо записи данных.</p>
<p>Для HTTPS-соединений, если некоторые данные записываются в соединение более чем через 10 секунд
    после первого принятия запроса, Go закроет базовое соединение вместо
    записи данных. Это означает, что если вы используете HTTPS (как мы), разумно установить
    WriteTimeout на значение, большее, чем ReadTimeout.</p>
<p>Важно помнить, что записи, выполненные обработчиком, буферизуются и записываются в соединение
    как единое целое, когда обработчик возвращается. Таким образом, идея WriteTimeout
    обычно заключается не в том, чтобы предотвратить длительную работу обработчиков, а в том, чтобы предотвратить
    слишком длительную запись данных, возвращаемых обработчиком.</p>

<h3>Дополнительная информация</h3>
<h4>Таймаут чтения заголовка</h4>
<p>Объект http.Server также предоставляет параметр ReadHeaderTimeout, который мы не использовали
    в нашем приложении. Это работает аналогично ReadTimeout, за исключением того, что оно применяется
    только к чтению заголовков HTTP(S). Итак, если вы установите ReadHeaderTimeout на 3 секунды,
    соединение будет закрыто, если заголовки запроса все еще читаются через 3 секунды после
    принятия запроса. Однако чтение тела запроса все равно может произойти по
    прошествии 3 секунд без закрытия соединения.</p>
<p>Это может быть полезно, если вы хотите применить общесерверное ограничение на чтение заголовков запросов, но
    хотите реализовать разные таймауты на разных маршрутах, когда дело доходит до чтения
    тело запроса (возможно, с использованием промежуточного программного обеспечения http.TimeoutHandler()).
    Для нашего веб-приложения Snippetbox у нас нет никаких действий, гарантирующих
    таймауты чтения для каждого маршрута — чтение заголовков и тел запросов для всех наших маршрутов должно быть
    удобно завершено за 5 секунд, поэтому мы будем придерживаться использования ReadTimeout.</p>
    
<p class="note">
    Предупреждение. Параметр ReadHeaderTimeout также влияет на поведение IdleTimeout.
    В частности, если вы установили ReadHeaderTimeout, но не установили ReadTimeout и не установили
    IdleTimeout, то для IdleTimeout по умолчанию будет использоваться тот же параметр, что и для
    ReadHeaderTimeout. Опять же, безопаснее (и понятнее) просто выработать привычку
    явно устанавливать IdleTimeout.</p>

<h3>Максимальное количество байт заголовка</h3>
<p>Объект http.Server также предоставляет поле MaxHeaderBytes, которое можно использовать для управления
    максимальным количеством байтов, которые сервер будет читать при анализе заголовков запросов. По
    умолчанию Go допускает максимальную длину заголовка 1 МБ.</p>
<p>Если вы хотите ограничить максимальную длину заголовка, например, 0,5 МБ, вы должны написать:</p>
<pre><code>
    srv := &http.Server{
        Addr: *addr,
        MaxHeaderBytes: 524288,
        ...
    }
</code></pre>

<p>Если значение MaxHeaderBytes превышено, пользователю автоматически будет отправлен
    ответ <span>431 Request Header Fields Too Large</span>.</p>
<p>Здесь следует отметить одну особенность: Go всегда добавляет дополнительные 4096 байт
    к заданному вами значению. Если вам нужно, чтобы MaxHeaderBytes было точным или очень небольшим числом, вам
    необходимо это учесть.</p>

<p>Конец главы 10</p>




</body>
</html>