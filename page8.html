     
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Page 2</title>
</head>
<body> 
<h1>Интерфейс http.Handler</h1>    
<p>Прежде чем мы пойдем дальше, мы должны обсудить небольшую теорию. Это немного сложно,
    поэтому, если эта глава покажется вам трудной, не волнуйтесь. Продолжайте сборку приложения и
    вернитесь к ней позже, когда вы лучше познакомитесь с Go.
</p>
<p>В предыдущих главах я использовал термин «обработчик», не объясняя, что он
    на самом деле означает. Строго говоря, под обработчиком мы подразумеваем объект, удовлетворяющий
    интерфейсу http.Handler:
</p>    
<pre><code>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}</code></pre>       
<p>Проще говоря, это означает, что для того, чтобы быть обработчиком, объект должен иметь
    метод ServeHTTP() с точной подписью:</p>
<pre><code>ServeHTTP(http.ResponseWriter, *http.Request)</code></pre>
<p>Таким образом, в простейшей форме обработчик может выглядеть примерно так:</p>

<pre><code>type home struct {}
    func (h *home) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("This is my home page"))
}</code></pre>
<p>Здесь у нас есть объект (в данном случае это домашняя структура, но в равной степени это может быть строка,
    функция или что-то еще), и мы реализовали метод с сигнатурой
    ServeHTTP(http.ResponseWriter, *http.Request) на это. Это все, что нам нужно для создания обработчика.
</p>
<p>Затем вы можете зарегистрировать это с помощью servermux, используя метод Handle, например:</p>
<pre><code>mux := http.NewServeMux()
    mux.Handle("/", &home{})</code></pre>

<h2>Функции обработчика</h2>
<p>Теперь создание объекта только для того, чтобы мы могли реализовать для него метод ServeHTTP(), долго и немного запутанно. Вот почему на практике гораздо чаще писать обработчики
    как обычную функцию (как мы делали до сих пор). Например:
</p>
<pre><code>func home(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("This is my home page"))
}</code></pre>
<p>Но эта домашняя функция — просто нормальная функция; у него нет метода ServeHTTP(). Так что
    сам по себе это не обработчик.</p>
<p>Вместо этого нам нужно преобразовать его в обработчик с помощью адаптера http.HandlerFunc(), например:</p>
<pre><code>mux := http.NewServeMux()
    mux.Handle("/", http.HandlerFunc(home))</code></pre>
<p>Адаптер http.HandlerFunc() автоматически добавляет метод ServeHTTP() к
    домашней функции. При выполнении этот метод ServeHTTP() просто вызывает содержимое
    исходной домашней функции. Это окольный, но удобный способ заставить обычную
    функцию удовлетворять требованиям интерфейса http.Handler.
</p>
<p>До сих пор в этом проекте мы использовали метод HandleFunc() для регистрации наших
    функций-обработчиков с помощью servemux. Это просто некий синтаксический сахар, который преобразует
    функцию в обработчик и регистрирует ее за один шаг, вместо того, чтобы делать это вручную. Приведенный выше код
    функционально эквивалентен этому:</p>
<pre><code>mux := http.NewServeMux()
    mux.HandleFunc("/", home)</code></pre>
<h2>Цепочка обработчиков</h2>
<p>Внимательные из вас могли заметить кое-что интересное в самом начале этого
    проекта. Функция http.ListenAndServe() принимает объект http.Handler в качестве второго
    параметра…
</p>    
<pre><code>func ListenAndServe(addr string, handler Handler) error</code></pre>
<p>… но мы передавали сервисмультиплексор.</p>
<p>Мы смогли это сделать, потому что у servermux также есть метод ServeHTTP(), что означает,
    что он также удовлетворяет интерфейсу http.Handler.
</p>
<p>Для меня упрощается представление о servermux как об особом виде обработчика,
    который вместо предоставления ответа сам передает запрос второму обработчику. Это
    не такой большой скачок, как может показаться на первый взгляд. Объединение обработчиков вместе — очень распространенная
    идиома в Go, и мы будем делать это позже в этом проекте.
</p>
<p>На самом деле происходит следующее: когда наш сервер получает новый HTTP-запрос, он
    вызывает метод ServeHTTP() сервисмультиплексора. Это ищет соответствующий обработчик на основе
    запрашивать URL-адрес и, в свою очередь, вызывает метод ServeHTTP() этого обработчика. Вы можете представить себе
    веб-приложение Go как цепочку методов ServeHTTP(), вызываемых один за другим.
</p>

<h2>Запросы обрабатываются одновременно</h2>
<p>Есть еще одна вещь, на которую действительно важно обратить внимание: все входящие HTTP-запросы обслуживаются
    в собственной горутине. Для загруженных серверов это означает, что очень вероятно, что код в
    ваших обработчиках или вызываемый ими будет выполняться одновременно. Хотя это помогает сделать Go невероятно
    быстрым, недостатком является то, что вам нужно знать (и защищаться) от условий гонки
    при доступе к общим ресурсам от ваших обработчиков.
</p>
</body>
</html>